<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arcade â€” ColeÃ§Ã£o</title>
  <style>
    :root{
      --card-bg:#fff;
      --accent:#3f7bff;
      --page-pad:18px;
      --card-w:320px;
      --page-max:1400px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background:linear-gradient(120deg,#eef6ff,#fbfcff);
      color:#13202a;
      padding:var(--page-pad);
      -webkit-font-smoothing:antialiased;
    }
    .site-title{ text-align:center; font-weight:800; margin:0 0 18px; }
    .site-title .animated-text{ display:inline-block; animation: colorCycle 3s linear infinite, blink 1s ease-in-out infinite; }
    @keyframes colorCycle{0%{color:#2ecc71}33%{color:#ff6b6b}66%{color:#ffd166}100%{color:#2ecc71}}
    @keyframes blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}
    @media (prefers-reduced-motion:reduce){ .site-title .animated-text{ animation:none; color:#2ecc71 } }

    .games-row{
      display:flex; flex-wrap:wrap; gap:18px;
      justify-content:center; max-width:var(--page-max); margin:0 auto;
    }
    .game-card{
      flex:0 0 var(--card-w); width:var(--card-w);
      background:var(--card-bg); border-radius:12px;
      box-shadow:0 10px 28px rgba(16,24,40,0.06); overflow:hidden;
      display:flex; flex-direction:column;
    }
    .game-card h2{ font-size:1rem; margin:12px; text-align:center; }
    .game-card__body{ padding:10px; display:flex; flex-direction:column; gap:8px; align-items:stretch; min-height:210px; }
    .game-inner{ flex:1 1 auto; display:flex; align-items:center; justify-content:center; padding:8px; min-height:120px; }
    .game-inner canvas{ width:100%; height:100%; display:block; border-radius:8px; background:#111; }
    .controls{ display:flex; gap:8px; justify-content:center; margin-top:6px; }
    .btn{ background:var(--accent); color:#fff; border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:700; }
    .small-note{ font-size:12px; text-align:center; color:#536370; }

    /* grid/board helpers */
    #mem-board{ display:grid; gap:8px; justify-content:center; width:100%; }
    .cell{ border-radius:8px; background:#56606a; width:56px; height:56px; display:flex; align-items:center; justify-content:center; color:transparent; font-size:22px; box-shadow:0 6px 14px rgba(10,20,40,0.05); }
    .cell.open{ background:#fff; color:#111; transform:scale(1.03) }
    .cell.matched{ background:#dff7e7; color:#0b5132 }

    /* Simon */
    .simon-grid{ display:grid; grid-template-columns:1fr 1fr; grid-template-rows:1fr 1fr; gap:10px; width:100%; height:100%; }
    .simon-pad{ border-radius:12px; display:flex; align-items:center; justify-content:center; font-weight:800; color:#111; user-select:none; }

    @media (max-width:960px){
      .game-card{ flex:1 1 92%; width:auto; }
      .site-title{ font-size:1.2rem; }
    }
  </style>
</head>
<body>

  <h1 class="site-title" role="heading" aria-level="1">
    <span class="animated-text">Jogue aqui os jogos arcade mais desejados de todos os tempos</span>
  </h1>

  <div class="games-row">

    <!-- Existing core games -->
    <div class="game-card" id="tetris-card"><h2>Tetris</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="tetris-score">0</span></div><div>NÃ­vel: <span id="tetris-level">1</span></div></div>
        <div class="game-inner"><canvas id="tetris-canvas" data-cols="10" data-rows="20"></canvas></div>
        <div class="controls"><button id="tetris-restart" class="btn">Reiniciar</button><button id="tetris-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <div class="game-card" id="mem-card"><h2>Memory</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:8px;font-weight:700"><div>NÃ­vel: <span id="mem-lvl">1</span></div><div>Mov.: <span id="mem-moves">0</span></div></div>
        <div class="game-inner"><div id="mem-board" aria-live="polite" style="width:100%;"></div></div>
        <div class="controls"><button id="mem-restart" class="btn">Reiniciar</button><button id="mem-next" class="btn" disabled>PrÃ³x</button></div>
      </div>
    </div>

    <div class="game-card" id="pong-card"><h2>Pong</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>A: <span id="pong-score-a">0</span></div><div>B: <span id="pong-score-b">0</span></div></div>
        <div class="game-inner"><canvas id="pong-canvas"></canvas></div>
        <div class="controls"><button id="pong-restart" class="btn">Reiniciar</button><button id="pong-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <div class="game-card" id="simon-card"><h2>Simon</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>NÃ­vel: <span id="simon-level">0</span></div><div>Recorde: <span id="simon-best">0</span></div></div>
        <div class="game-inner"><div class="simon-grid" id="simon-grid">
          <div class="simon-pad" id="pad-0" style="background:#2ecc71"></div>
          <div class="simon-pad" id="pad-1" style="background:#ffd166"></div>
          <div class="simon-pad" id="pad-2" style="background:#ff6b6b"></div>
          <div class="simon-pad" id="pad-3" style="background:#9b5cff"></div>
        </div></div>
        <div class="controls"><button id="simon-start" class="btn">Start</button><button id="simon-strict" class="btn">Strict</button></div>
      </div>
    </div>

    <div class="game-card" id="flappy-card"><h2>Flappy</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="flappy-score">0</span></div><div>Best: <span id="flappy-best">0</span></div></div>
        <div class="game-inner"><canvas id="flappy-canvas" style="background:#70c5ce"></canvas></div>
        <div class="controls"><button id="flappy-restart" class="btn">Reiniciar</button><button id="flappy-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <!-- New requested games -->
    <div class="game-card" id="snake-card"><h2>Snake</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="snake-score">0</span></div></div>
        <div class="game-inner"><canvas id="snake-canvas"></canvas></div>
        <div class="controls"><button id="snake-restart" class="btn">Reiniciar</button><button id="snake-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <div class="game-card" id="breakout-card"><h2>Breakout</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="breakout-score">0</span></div></div>
        <div class="game-inner"><canvas id="breakout-canvas"></canvas></div>
        <div class="controls"><button id="breakout-restart" class="btn">Reiniciar</button><button id="breakout-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <div class="game-card" id="invaders-card"><h2>Space Invaders</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="invaders-score">0</span></div></div>
        <div class="game-inner"><canvas id="invaders-canvas"></canvas></div>
        <div class="controls"><button id="invaders-restart" class="btn">Reiniciar</button><button id="invaders-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <div class="game-card" id="asteroids-card"><h2>Asteroids</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="asteroids-score">0</span></div></div>
        <div class="game-inner"><canvas id="asteroids-canvas"></canvas></div>
        <div class="controls"><button id="asteroids-restart" class="btn">Reiniciar</button><button id="asteroids-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <div class="game-card" id="pacman-card"><h2>Pacâ€‘Man (lite)</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="pacman-score">0</span></div></div>
        <div class="game-inner"><canvas id="pacman-canvas"></canvas></div>
        <div class="controls"><button id="pacman-restart" class="btn">Reiniciar</button><button id="pacman-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <div class="game-card" id="frogger-card"><h2>Frogger</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Level: <span id="frogger-level">1</span></div></div>
        <div class="game-inner"><canvas id="frogger-canvas"></canvas></div>
        <div class="controls"><button id="frogger-restart" class="btn">Reiniciar</button></div>
      </div>
    </div>

    <div class="game-card" id="bubble-card"><h2>Bubble Shooter</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="bubble-score">0</span></div></div>
        <div class="game-inner"><canvas id="bubble-canvas"></canvas></div>
        <div class="controls"><button id="bubble-restart" class="btn">Reiniciar</button></div>
      </div>
    </div>

    <div class="game-card" id="runner-card"><h2>Endless Runner</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="runner-score">0</span></div></div>
        <div class="game-inner"><canvas id="runner-canvas"></canvas></div>
        <div class="controls"><button id="runner-restart" class="btn">Reiniciar</button></div>
      </div>
    </div>

  </div>

  <!-- ================= SCRIPTS: helper utilities (shared) ================= -->
  <script>
  // Small helper: fit a canvas to its .game-inner wrapper with DPR
  function fitCanvasToWrapper(canvas){
    const dpr = window.devicePixelRatio || 1;
    const wrap = canvas.closest('.game-inner') || canvas.parentElement || document.body;
    const rect = wrap.getBoundingClientRect();
    const w = Math.max(80, Math.floor(rect.width));
    const h = Math.max(80, Math.floor(rect.height));
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    const rw = Math.floor(w * dpr), rh = Math.floor(h * dpr);
    if(canvas.width !== rw || canvas.height !== rh){
      canvas.width = rw; canvas.height = rh;
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return true;
    }
    return false;
  }
  window.addEventListener('resize', ()=>{ document.querySelectorAll('canvas').forEach(c => { try{ fitCanvasToWrapper(c);}catch(e){} }); });
  window.addEventListener('load', ()=>{ setTimeout(()=>document.querySelectorAll('canvas').forEach(c => { try{ fitCanvasToWrapper(c);}catch(e){} }),120); });
  </script>

  <!-- ================= TETRIS (kept simplified) ================= -->
  <script>
  (function(){
    const canvas = document.getElementById('tetris-canvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const COLS = 10, ROWS = 20;
    let board = [], piece=null, queue=[], score=0, level=1, lines=0, acc=0, last=0, paused=false;
    const shapes = {
      I:[[1,1,1,1]],
      O:[[1,1],[1,1]],
      T:[[0,1,0],[1,1,1]],
      S:[[0,1,1],[1,1,0]],
      Z:[[1,1,0],[0,1,1]],
      J:[[1,0,0],[1,1,1]],
      L:[[0,0,1],[1,1,1]]
    };
    const colors = {I:'#00d2ff',O:'#ffd86b',T:'#9b5cff',S:'#2ecc71',Z:'#ff6b6b',J:'#ff8a5c',L:'#ffd166'};
    function rotate(m){ const a=Array.from({length:m[0].length},()=>[]); for(let r=0;r<m.length;r++)for(let c=0;c<m[r].length;c++)a[c][m.length-1-r]=m[r][c]; return a;}
    function bag(){ const k=Object.keys(shapes); let b=k.slice(); for(let i=b.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [b[i],b[j]]=[b[j],b[i]];} queue.push(...b); }
    function newBoard(){ board=Array.from({length:ROWS},()=>Array(COLS).fill(0)); }
    function spawn(){ if(queue.length<3)bag(); const t=queue.shift(); piece={t,rot:0,x:Math.floor((COLS- (shapes[t][0].length))/2),y:-shapes[t].length}; if(collide(piece,0,0)) paused=true; }
    function collide(p,dx,dy,rotIdx){ const mat = (function(){ let m=shapes[p.t][0]; for(let i=0;i<rotIdx;i++) m=rotate(m); return m; })(); for(let r=0;r<mat.length;r++)for(let c=0;c<mat[r].length;c++)if(mat[r][c]){ const nx=p.x+c+dx, ny=p.y+r+dy; if(nx<0||nx>=COLS) return true; if(ny>=ROWS) return true; if(ny>=0 && board[ny][nx]) return true; } return false; }
    function lock(){ const mat= (function(){ let m=shapes[piece.t][0]; for(let i=0;i<piece.rot;i++) m=rotate(m); return m; })(); for(let r=0;r<mat.length;r++) for(let c=0;c<mat[r].length;c++) if(mat[r][c]){ const ny=piece.y+r, nx=piece.x+c; if(ny>=0) board[ny][nx]=piece.t; } clearLines(); spawn(); }
    function clearLines(){ let removed=0; for(let r=ROWS-1;r>=0;r--){ if(board[r].every(x=>x)){ board.splice(r,1); board.unshift(Array(COLS).fill(0)); removed++; r++; }} if(removed){ lines+=removed; score+= [0,40,100,300,1200][removed]*level; level=Math.floor(lines/10)+1; document.getElementById('tetris-score').textContent=score; document.getElementById('tetris-level').textContent=level; } }
    function move(dx){ if(!piece||paused) return; if(!collide(piece,dx,0)) piece.x+=dx; }
    function rotatePiece(){ if(!piece||paused) return; const next=(piece.rot+1)%4; const kicks=[0,-1,1,-2,2]; for(let k of kicks) if(!collide(piece,k,0,next)){ piece.x+=k; piece.rot=next; break; } }
    function drop(){ if(!piece||paused) return; if(!collide(piece,0,1)) piece.y++; else lock(); }
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') move(-1); if(e.key==='ArrowRight') move(1); if(e.key==='ArrowUp') rotatePiece(); if(e.key==='ArrowDown'){ drop(); score++; document.getElementById('tetris-score').textContent=score;} if(e.key===' ') { while(!collide(piece,0,1)) piece.y++; lock(); } if(e.key==='p' || e.key==='P'){ paused=!paused; document.getElementById('tetris-pause').textContent= paused?'Retomar':'Pausar'; } });
    document.getElementById('tetris-restart').addEventListener('click', ()=>init(true)); document.getElementById('tetris-pause').addEventListener('click', ()=>{ paused=!paused; document.getElementById('tetris-pause').textContent= paused?'Retomar':'Pausar'; });

    function draw(){
      fitCanvasToWrapper(canvas);
      const cell = Math.floor(canvas.clientWidth / COLS);
      const offX = Math.floor((canvas.clientWidth - cell*COLS)/2);
      const offY = Math.floor((canvas.clientHeight - cell*ROWS)/2);
      ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      ctx.strokeStyle='rgba(255,255,255,0.03)';
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        const x=offX+c*cell, y=offY+r*cell;
        ctx.fillStyle='#101115'; ctx.fillRect(x,y,cell,cell);
        if(board[r][c]){ ctx.fillStyle=colors[board[r][c]]||'#999'; ctx.fillRect(x+2,y+2,cell-4,cell-4); ctx.strokeRect(x+2,y+2,cell-4,cell-4); }
      }
      if(piece){
        let mat=shapes[piece.t][0]; for(let i=0;i<piece.rot;i++) mat=rotate(mat);
        for(let r=0;r<mat.length;r++) for(let c=0;c<mat[r].length;c++) if(mat[r][c]){
          const x = offX + (piece.x+c)*cell, y = offY + (piece.y+r)*cell;
          if(y+cell<offY) continue;
          ctx.fillStyle = colors[piece.t]; ctx.fillRect(x+2,y+2,cell-4,cell-4); ctx.strokeRect(x+2,y+2,cell-4,cell-4);
        }
      }
    }

    function loop(ts){
      if(!last) last=ts; const dt=ts-last; last=ts;
      if(!paused){ acc+=dt; const interval=Math.max(120,800 - (level-1)*60); while(acc>=interval){ drop(); acc-=interval; } }
      draw(); requestAnimationFrame(loop);
    }

    function init(full){
      newBoard(); queue=[]; if(full) bag(); spawn(); score=0; level=1; lines=0; acc=0; last=0; paused=false; document.getElementById('tetris-score').textContent=score; document.getElementById('tetris-level').textContent=level;
    }
    init(true); requestAnimationFrame(loop);
    window.addEventListener('resize', ()=>fitCanvasToWrapper(canvas));
  })();
  </script>

  <!-- MEMORY (compact) -->
  <script>
  (function(){
    const boardEl = document.getElementById('mem-board');
    const movesEl = document.getElementById('mem-moves');
    const scoreEl = document.getElementById('mem-score');
    const lvlEl = document.getElementById('mem-lvl');
    let level=0, rows=4, cols=4, board=[], first=null, second=null, lock=false, moves=0, score=0, matches=0;
    const SYMBOLS=['ðŸŽ','ðŸ‹','ðŸ‡','ðŸ“','ðŸ‰','ðŸ’','ðŸŠ','ðŸ¥','ðŸ','ðŸ¥‘','ðŸ‘','ðŸŒ','ðŸ','ðŸˆ','ðŸ¥¥','ðŸ'];
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
    function setGrid(){
      const pairs = (rows*cols)/2; const pool=shuffle(SYMBOLS.slice()); const chosen=pool.slice(0,pairs); const symbols=shuffle([...chosen,...chosen]);
      board=symbols.map((s,i)=>({id:i,symbol:s,matched:false}));
      const cellSize = Math.max(40, Math.min(80, Math.floor((document.querySelector('#mem-card .game-inner').clientWidth - 20)/cols)));
      boardEl.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
      boardEl.innerHTML=''; board.forEach(c=>{
        const b=document.createElement('button'); b.className='cell'; b.dataset.id=c.id; b.style.width=cellSize+'px'; b.style.height=cellSize+'px'; b.innerHTML='<span></span>'; b.addEventListener('click', onClick); boardEl.appendChild(b);
      });
    }
    function build(){
      const sizes=[{r:2,c:2},{r:2,c:3},{r:3,c:4},{r:4,c:4},{r:4,c:5}];
      const spec = level<sizes.length?sizes[level]:{r:Math.min(8,4+Math.floor((level-sizes.length)/2)), c:Math.min(8,5+((level-sizes.length)%2))};
      rows=spec.r; cols=spec.c; setGrid(); first=second=null; lock=false; moves=0; score=0; matches=0; movesEl.textContent=moves; scoreEl.textContent=score; lvlEl.textContent=level+1;
    }
    function openCard(el,card){ el.classList.add('open'); el.querySelector('span').textContent=card.symbol; }
    function closeCard(el){ el.classList.remove('open'); el.querySelector('span').textContent=''; }
    function onClick(e){
      if(lock) return; const el=e.currentTarget; const id=+el.dataset.id; const card=board[id]; if(card.matched) return;
      if(first && first.id===id) return;
      openCard(el,card);
      if(!first){ first={id,el,card}; return; }
      second={id,el,card}; moves++; movesEl.textContent=moves; lock=true;
      if(first.card.symbol===second.card.symbol){ setTimeout(()=>{ first.card.matched=second.card.matched=true; first.el.classList.add('matched'); second.el.classList.add('matched'); matches++; score+=10; scoreEl.textContent=score; first=second=null; lock=false; checkWin(); },300); }
      else { setTimeout(()=>{ closeCard(first.el); closeCard(second.el); score=Math.max(0,score-1); scoreEl.textContent=score; first=second=null; lock=false; },700); }
    }
    function checkWin(){ if(matches=== (rows*cols)/2){ /* next enabled */ } }
    document.getElementById('mem-restart').addEventListener('click',build);
    document.getElementById('mem-next').addEventListener('click', ()=>{ level++; build(); });
    window.addEventListener('resize', ()=>{ setTimeout(()=>setGrid(),120); });
    build();
  })();
  </script>

  <!-- PONG (compact) -->
  <script>
  (function(){
    const canvas = document.getElementById('pong-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d'); let left={y:0,vy:0,score:0}, right={y:0,vy:0,score:0}, paddleW=8,paddleH=80,ball={x:0,y:0,vx:120,vy:20}, last=0, paused=false;
    function resize(){ fitCanvasToWrapper(canvas); const cssW=canvas.clientWidth, cssH=canvas.clientHeight; paddleH=Math.max(40,cssH*0.18); paddleW=Math.max(6,cssW*0.02); left.y=right.y=(cssH-paddleH)/2; ball.x=cssW/2; ball.y=cssH/2; ball.vx = 120*(Math.random()<0.5?1:-1); }
    function update(dt){ if(paused) return; left.y = Math.max(0,Math.min(canvas.clientHeight-paddleH,left.y+left.vy*dt)); right.y = Math.max(0,Math.min(canvas.clientHeight-paddleH,right.y+right.vy*dt)); ball.x += ball.vx*dt; ball.y += ball.vy*dt;
      if(ball.y<5||ball.y>canvas.clientHeight-5) ball.vy=-ball.vy;
      if(ball.x < 0){ right.score++; document.getElementById('pong-score-b').textContent=right.score; resetBall(1); }
      if(ball.x > canvas.clientWidth){ left.score++; document.getElementById('pong-score-a').textContent=left.score; resetBall(-1); }
      // collisions
      if(ball.x - 6 < 12 + paddleW && ball.y > left.y && ball.y < left.y + paddleH) { ball.vx = Math.abs(ball.vx); }
      if(ball.x + 6 > canvas.clientWidth - (12 + paddleW) && ball.y > right.y && ball.y < right.y + paddleH) { ball.vx = -Math.abs(ball.vx); }
    }
    function resetBall(dir){ ball.x=canvas.clientWidth/2; ball.y=canvas.clientHeight/2; ball.vx = 120 * dir * (1+Math.random()*0.4); ball.vy = (Math.random()-0.5)*160; }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); ctx.fillStyle='rgba(255,255,255,0.06)'; for(let y=0;y<canvas.clientHeight;y+=24) ctx.fillRect(canvas.clientWidth/2-1,y+6,2,12); ctx.fillStyle='#fff'; ctx.fillRect(12,left.y,paddleW,paddleH); ctx.fillRect(canvas.clientWidth-12-paddleW,right.y,paddleW,paddleH); ctx.beginPath(); ctx.fillStyle='#ff7b7b'; ctx.arc(ball.x,ball.y,8,0,Math.PI*2); ctx.fill(); }
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('keydown', e=>{ if(e.key==='w') left.vy=-160; if(e.key==='s') left.vy=160; if(e.key==='ArrowUp') right.vy=-160; if(e.key==='ArrowDown') right.vy=160; if(e.key==='p'){ paused=!paused; document.getElementById('pong-pause').textContent=paused?'Retomar':'Pausar'; }});
    window.addEventListener('keyup', e=>{ if(e.key==='w'||e.key==='s') left.vy=0; if(e.key==='ArrowUp'||e.key==='ArrowDown') right.vy=0; });
    document.getElementById('pong-restart').addEventListener('click', ()=>{ left.score=right.score=0; document.getElementById('pong-score-a').textContent=0; document.getElementById('pong-score-b').textContent=0; resetBall(1); paused=false; });
    document.getElementById('pong-pause').addEventListener('click', ()=>{ paused=!paused; document.getElementById('pong-pause').textContent=paused?'Retomar':'Pausar'; });
    window.addEventListener('resize', ()=>resize()); window.addEventListener('load', ()=>{ resize(); resetBall(1); requestAnimationFrame(loop); });
  })();
  </script>

  <!-- SIMON (improved) -->
  <script>
  (function(){
    const pads = Array.from(document.querySelectorAll('#simon-grid .simon-pad'));
    if(!pads.length) return;
    const startBtn = document.getElementById('simon-start'), strictBtn = document.getElementById('simon-strict');
    const levelEl = document.getElementById('simon-level'), bestEl = document.getElementById('simon-best');
    const aCtx = window.AudioContext? new AudioContext():null; const freqs=[440,523.25,659.25,349.23];
    let seq=[], idx=0, playing=false, busy=false, strict=false, best=Number(localStorage.getItem('simon-best')||0);
    bestEl.textContent=best;
    function tone(i,d=300){ if(!aCtx) return; const o=aCtx.createOscillator(), g=aCtx.createGain(); o.frequency.value=freqs[i]; o.connect(g); g.connect(aCtx.destination); g.gain.setValueAtTime(0.001,aCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.12,aCtx.currentTime+0.02); o.start(); g.gain.exponentialRampToValueAtTime(0.001,aCtx.currentTime+d/1000); o.stop(aCtx.currentTime+d/1000+0.02); }
    function flash(i,ms=300){ return new Promise(r=>{ const p=pads[i]; p.classList.add('active'); tone(i,ms); setTimeout(()=>{ p.classList.remove('active'); setTimeout(r,120); },ms); }); }
    async function playSeq(){ busy=true; for(let v of seq){ await flash(v, Math.max(180,400-seq.length*6)); } busy=false; }
    function nextRound(){ seq.push(Math.floor(Math.random()*4)); levelEl.textContent=seq.length; if(seq.length>best){ best=seq.length; localStorage.setItem('simon-best',best); bestEl.textContent=best; } playSeq().then(()=>{ idx=0; playing=true; }); }
    function reset(){ seq=[]; idx=0; playing=false; busy=false; levelEl.textContent=0; }
    pads.forEach((p,i)=>{ p.addEventListener('click', ()=>{ if(aCtx && aCtx.state==='suspended') aCtx.resume(); if(busy) return; if(!playing) return; flash(i,160); if(seq[idx]===i){ idx++; if(idx>=seq.length){ playing=false; setTimeout(()=>nextRound(),420); } } else { // wrong
      busy=true; pads.forEach(x=>x.classList.add('dim')); if(aCtx){ try{ const o=aCtx.createOscillator(); const g=aCtx.createGain(); o.frequency.value=120; o.connect(g); g.connect(aCtx.destination); g.gain.value=0.08; o.start(); setTimeout(()=>o.stop(),300);}catch(e){} }
      setTimeout(async ()=>{ pads.forEach(x=>x.classList.remove('dim')); busy=false; if(strict){ reset(); start(); } else { idx=0; await playSeq(); playing=true; } },500);
    }}); p.addEventListener('touchstart', e=>{ e.preventDefault(); p.click(); },{passive:false}); });
    function start(){ if(aCtx && aCtx.state==='suspended') aCtx.resume(); reset(); setTimeout(()=>nextRound(),180); }
    startBtn.addEventListener('click', start); strictBtn.addEventListener('click', ()=>{ strict=!strict; strictBtn.style.opacity = strict? '1':'0.6'; });
    // initial dim
    pads.forEach(p=>p.classList.add('dim'));
  })();
  </script>

  <!-- FLAPPY (improved drawing) -->
  <script>
  (function(){
    const canvas = document.getElementById('flappy-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d'); const scoreEl = document.getElementById('flappy-score'), bestEl = document.getElementById('flappy-best');
    let best = Number(localStorage.getItem('flappy-best')||0); bestEl.textContent=best;
    function fit(){ fitCanvasToWrapper(canvas); }
    let bird={x:60,y:120,vy:0,r:12}, pipes=[], gravity=900, flap=-340, spawnT=0, spawnI=1.5, speed=120, last=0, score=0, running=false, paused=false;
    function reset(){ fit(); const w=canvas.clientWidth,h=canvas.clientHeight; bird.x=Math.max(40,w*0.18); bird.y=h/2; bird.vy=0; bird.r=Math.max(8,Math.min(18,Math.floor(h*0.035))); pipes=[]; spawnT=0; score=0; running=true; paused=false; scoreEl.textContent=0; }
    function spawn(){ const w=canvas.clientWidth,h=canvas.clientHeight; const gap=Math.max(70,Math.floor(h*0.22)); const gapY=Math.floor(60+Math.random()*(h-140-gap)); pipes.push({x:w+20,gapY,wid:Math.max(46,Math.floor(w*0.14)),gapH:gap,passed:false}); }
    function flapFn(){ if(!running){ reset(); last=performance.now(); requestAnimationFrame(loop); return; } bird.vy=flap; }
    function step(dt){ if(paused||!running) return; bird.vy+=gravity*dt; bird.y+=bird.vy*dt; pipes.forEach(p=>p.x-=speed*dt); spawnT+=dt; if(spawnT>=spawnI){ spawnT=0; spawn(); } if(pipes.length && pipes[0].x + pipes[0].wid < -30) pipes.shift(); const h=canvas.clientHeight; if(bird.y-bird.r<=0||bird.y+bird.r>=h-40) running=false; for(let p of pipes){ if(!p.passed && p.x + p.wid < bird.x){ p.passed=true; score++; scoreEl.textContent=score; if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('flappy-best',best);} } if(bird.x+bird.r>p.x && bird.x-bird.r<p.x+p.wid){ if(bird.y-bird.r < p.gapY || bird.y+bird.r > p.gapY + p.gapH) running=false; } } }
    function drawBird(x,y,r){ ctx.beginPath(); ctx.fillStyle='#ffde59'; ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle='#111'; ctx.arc(x + r*0.35, y - r*0.25, Math.max(1.4, r*0.18),0,Math.PI*2); ctx.fill(); ctx.fillStyle='#ff8a2f'; ctx.beginPath(); ctx.moveTo(x + r, y); ctx.lineTo(x + r + r*0.9, y - r*0.35); ctx.lineTo(x + r + r*0.9, y + r*0.35); ctx.closePath(); ctx.fill(); }
    function draw(){ const w=canvas.clientWidth,h=canvas.clientHeight; ctx.fillStyle='#70c5ce'; ctx.fillRect(0,0,w,h); ctx.fillStyle='#6abf9f'; ctx.fillRect(0,h-40,w,40); for(let p of pipes){ ctx.fillStyle='#2d8a57'; ctx.fillRect(p.x,0,p.wid,p.gapY); ctx.fillRect(p.x,p.gapY+p.gapH,p.wid,h-(p.gapY+p.gapH)-40); ctx.fillStyle='#1f5f3f'; ctx.fillRect(p.x,p.gapY-6,p.wid,6); ctx.fillRect(p.x,p.gapY+p.gapH,p.wid,6); } drawBird(bird.x,bird.y,bird.r); }
    function loop(ts){ if(!last) last=ts; const dt=Math.min(0.05,(ts-last)/1000); last=ts; step(dt); draw(); requestAnimationFrame(loop); }
    canvas.addEventListener('click', ()=>flapFn()); canvas.addEventListener('touchstart', e=>{ e.preventDefault(); flapFn(); },{passive:false});
    document.getElementById('flappy-restart').addEventListener('click', ()=>{ reset(); last=performance.now(); requestAnimationFrame(loop); });
    document.getElementById('flappy-pause').addEventListener('click', ()=>{ paused=!paused; document.getElementById('flappy-pause').textContent=paused?'Retomar':'Pausar'; });
    window.addEventListener('load', ()=>{ fit(); reset(); last=performance.now(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- SNAKE -->
  <script>
  (function(){
    const canvas = document.getElementById('snake-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d'); let grid=18, snake=[], dir={x:1,y:0}, food={x:8,y:8}, last=0, speed=8, score=0, running=true, paused=false;
    function fit(){ fitCanvasToWrapper(canvas); grid=Math.max(10, Math.floor(canvas.clientWidth/18)); }
    function reset(){ fit(); snake=[{x:5,y:5},{x:4,y:5},{x:3,y:5}]; dir={x:1,y:0}; placeFood(); score=0; document.getElementById('snake-score').textContent=0; running=true; }
    function placeFood(){ const cols = Math.floor(canvas.clientWidth / (Math.floor(canvas.clientWidth/grid))); const rows = Math.floor(canvas.clientHeight / (Math.floor(canvas.clientHeight/grid))); food.x = Math.floor(Math.random()* (Math.floor(canvas.clientWidth/(Math.floor(canvas.clientWidth/grid)))-2))+1; food.y = Math.floor(Math.random()* (Math.floor(canvas.clientHeight/(Math.floor(canvas.clientHeight/grid)))-2))+1; }
    function update(){ const head={x:snake[0].x+dir.x, y:snake[0].y+dir.y}; // wrap
      if(head.x<0) head.x = Math.floor(canvas.clientWidth / grid)-1; if(head.x>=Math.floor(canvas.clientWidth / grid)) head.x=0;
      if(head.y<0) head.y = Math.floor(canvas.clientHeight / grid)-1; if(head.y>=Math.floor(canvas.clientHeight / grid)) head.y=0;
      if(snake.some(s=>s.x===head.x&&s.y===head.y)){ running=false; return; }
      snake.unshift(head);
      if(Math.abs(head.x-food.x)<=0 && Math.abs(head.y-food.y)<=0){ score+=10; document.getElementById('snake-score').textContent=score; placeFood(); } else snake.pop();
    }
    function draw(){ fitCanvasToWrapper(canvas); const cell = Math.max(6, Math.floor(canvas.clientWidth / Math.floor(canvas.clientWidth/grid))); ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); ctx.fillStyle='#2ecc71'; snake.forEach((s,i)=>{ ctx.fillRect(s.x*cell, s.y*cell, cell-1, cell-1); }); ctx.fillStyle='#ff6b6b'; ctx.fillRect(food.x*cell, food.y*cell, cell-1, cell-1); }
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; if(!paused && running){ if(dt>1/speed){ update(); last=ts; } } draw(); requestAnimationFrame(loop); }
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowUp' && dir.y!==1){ dir={x:0,y:-1}; } if(e.key==='ArrowDown' && dir.y!==-1){ dir={x:0,y:1}; } if(e.key==='ArrowLeft' && dir.x!==1){ dir={x:-1,y:0}; } if(e.key==='ArrowRight' && dir.x!==-1){ dir={x:1,y:0}; } if(e.key==='p'){ paused=!paused; document.getElementById('snake-pause').textContent=paused?'Retomar':'Pausar'; } });
    document.getElementById('snake-restart').addEventListener('click', ()=>reset()); document.getElementById('snake-pause').addEventListener('click', ()=>{ paused=!paused; document.getElementById('snake-pause').textContent=paused?'Retomar':'Pausar'; });
    window.addEventListener('load', ()=>{ fit(); reset(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- BREAKOUT (simple) -->
  <script>
  (function(){
    const canvas = document.getElementById('breakout-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d');
    let paddle={w:80,h:12,x:0}, ball={x:0,y:0,vx:140,vy:-140,r:8}, bricks=[], rows=4, cols=6, last=0, score=0, paused=false;
    function fit(){ fitCanvasToWrapper(canvas); const cw=canvas.clientWidth; paddle.w=Math.max(60,Math.floor(cw*0.25)); paddle.x=(cw-paddle.w)/2; ball.x=cw/2; ball.y=canvas.clientHeight-60; }
    function buildBricks(){ bricks=[]; const cw=canvas.clientWidth; const cellW=Math.floor((cw-20)/cols); for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ bricks.push({x:10+c*(cellW+4), y:20+r*22, w:cellW, h:18, alive:true}); }} }
    function update(dt){ if(paused) return; ball.x+=ball.vx*dt; ball.y+=ball.vy*dt; if(ball.x-ball.r<0||ball.x+ball.r>canvas.clientWidth) ball.vx=-ball.vx; if(ball.y-ball.r<0) ball.vy=-ball.vy; if(ball.y+ball.r>canvas.clientHeight){ // lose a life -> reset
        ball.x=canvas.clientWidth/2; ball.y=canvas.clientHeight-60; ball.vy=-140; score=0; document.getElementById('breakout-score').textContent=score;
      }
      // paddle
      if(ball.x>paddle.x && ball.x<paddle.x+paddle.w && ball.y+ball.r >= canvas.clientHeight-40) { ball.vy = -Math.abs(ball.vy); ball.vx *= 1.02; }
      // bricks
      bricks.forEach(b=>{ if(b.alive && ball.x>b.x && ball.x<b.x+b.w && ball.y>b.y && ball.y<b.y+b.h){ b.alive=false; ball.vy=-ball.vy; score+=5; document.getElementById('breakout-score').textContent=score; } });
    }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); bricks.forEach(b=>{ if(b.alive){ ctx.fillStyle='#ffd166'; ctx.fillRect(b.x,b.y,b.w,b.h); ctx.strokeStyle='#b88600'; ctx.strokeRect(b.x,b.y,b.w,b.h); }}); ctx.fillStyle='#fff'; ctx.fillRect(paddle.x, canvas.clientHeight-40, paddle.w, paddle.h); ctx.beginPath(); ctx.fillStyle='#ff6b6b'; ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill(); }
    window.addEventListener('mousemove', e=>{ const rect=canvas.getBoundingClientRect(); paddle.x = Math.min(Math.max(0, e.clientX - rect.left - paddle.w/2), canvas.clientWidth - paddle.w); });
    document.getElementById('breakout-restart').addEventListener('click', ()=>{ score=0; document.getElementById('breakout-score').textContent=0; buildBricks(); ball.x=canvas.clientWidth/2; ball.y=canvas.clientHeight-60; ball.vy=-140; });
    document.getElementById('breakout-pause').addEventListener('click', ()=>{ paused=!paused; document.getElementById('breakout-pause').textContent=paused?'Retomar':'Pausar'; });
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('load', ()=>{ fit(); buildBricks(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>{ fit(); buildBricks(); });
  })();
  </script>

  <!-- SPACE INVADERS (simple) -->
  <script>
  (function(){
    const canvas = document.getElementById('invaders-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d'); let ship={x:0,y:0,w:28,h:12}, bullets=[], invaders=[], invVel=20, last=0, score=0, paused=false;
    function fit(){ fitCanvasToWrapper(canvas); ship.x = canvas.clientWidth/2 - ship.w/2; ship.y = canvas.clientHeight - 50; buildInvaders(); }
    function buildInvaders(){ invaders=[]; const cols=8, rows=3; const gap=8; const w=32; const startX=20; for(let r=0;r<rows;r++)for(let c=0;c<cols;c++) invaders.push({x:startX + c*(w+gap), y:40+r*(w*0.6), w:w, h:18, alive:true}); }
    function update(dt){ if(paused) return; invaders.forEach(i=>i.x += invVel*dt); const rightMost=Math.max(...invaders.map(i=>i.alive?i.x+i.w:0)); const leftMost=Math.min(...invaders.map(i=>i.alive?i.x:canvas.clientWidth)); if(rightMost>canvas.clientWidth-10 || leftMost<10){ invVel *= -1; invaders.forEach(i=>i.y+=10); } bullets.forEach(b=>b.y-=b.v*dt); bullets.filter(b=>b.y>0);
      // collisions
      bullets.forEach(b=>{ invaders.forEach(inv=>{ if(inv.alive && b.x>inv.x && b.x<inv.x+inv.w && b.y>inv.y && b.y<inv.y+inv.h){ inv.alive=false; b.hit=true; score+=10; document.getElementById('invaders-score').textContent=score; } }); });
      bullets = bullets.filter(b=>!b.hit && b.y>0);
    }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); ctx.fillStyle='#4ecdc4'; ctx.fillRect(ship.x,ship.y,ship.w,ship.h); invaders.forEach(inv=>{ if(inv.alive){ ctx.fillStyle='#ffd166'; ctx.fillRect(inv.x,inv.y,inv.w,inv.h); } }); ctx.fillStyle='#ff6b6b'; bullets.forEach(b=>{ ctx.fillRect(b.x-2,b.y-8,4,8); }); }
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') ship.x -= 12; if(e.key==='ArrowRight') ship.x += 12; if(e.key===' ') bullets.push({x:ship.x+ship.w/2,y:ship.y, v:320}); if(e.key==='p'){ paused=!paused; document.getElementById('invaders-pause').textContent=paused?'Retomar':'Pausar'; } });
    document.getElementById('invaders-restart').addEventListener('click', ()=>{ score=0; document.getElementById('invaders-score').textContent=0; buildInvaders(); });
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('load', ()=>{ fit(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- ASTEROIDS (simple) -->
  <script>
  (function(){
    const canvas = document.getElementById('asteroids-canvas'); if(!canvas) return; const ctx = canvas.getContext('2d');
    let ship={x:100,y:100,a:0,vx:0,vy:0}, asts=[], bullets=[], last=0, score=0;
    function fit(){ fitCanvasToWrapper(canvas); ship.x=canvas.clientWidth/2; ship.y=canvas.clientHeight/2; spawnAsteroids(4); }
    function spawnAsteroids(n){ asts=[]; for(let i=0;i<n;i++){ asts.push({x:Math.random()*canvas.clientWidth,y:Math.random()*canvas.clientHeight,vx:(Math.random()-0.5)*80,vy:(Math.random()-0.5)*80,r:20+Math.random()*30}); } }
    function update(dt){ ship.x+=ship.vx*dt; ship.y+=ship.vy*dt; ship.x=(ship.x+canvas.clientWidth)%canvas.clientWidth; ship.y=(ship.y+canvas.clientHeight)%canvas.clientHeight;
      asts.forEach(a=>{ a.x+=a.vx*dt; a.y+=a.vy*dt; a.x=(a.x+canvas.clientWidth)%canvas.clientWidth; a.y=(a.y+canvas.clientHeight)%canvas.clientHeight; });
      bullets.forEach(b=>{ b.x+=b.vx*dt; b.y+=b.vy*dt; });
      // collisions bullet-ast
      bullets.forEach(b=>{ asts.forEach(a=>{ if(Math.hypot(a.x-b.x,a.y-b.y) < a.r){ a.dead=true; b.dead=true; score+=5; document.getElementById('asteroids-score').textContent=score; } }); });
      asts = asts.filter(a=>!a.dead); bullets = bullets.filter(b=>!b.dead && b.x> -50 && b.x<canvas.clientWidth+50);
      if(Math.random()<0.005) spawnAsteroids(1);
    }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); ctx.save(); ctx.translate(ship.x,ship.y); ctx.rotate(ship.a); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(-8,6); ctx.lineTo(-6,0); ctx.lineTo(-8,-6); ctx.closePath(); ctx.fill(); ctx.restore();
      asts.forEach(a=>{ ctx.beginPath(); ctx.fillStyle='#bdb76b'; ctx.arc(a.x,a.y,a.r,0,Math.PI*2); ctx.fill(); });
      bullets.forEach(b=>{ ctx.fillStyle='#ff6b6b'; ctx.fillRect(b.x-2,b.y-2,4,4); }); }
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') ship.a -= 0.14; if(e.key==='ArrowRight') ship.a += 0.14; if(e.key==='ArrowUp'){ ship.vx += Math.cos(ship.a)*6; ship.vy += Math.sin(ship.a)*6; } if(e.key===' ') bullets.push({x:ship.x+Math.cos(ship.a)*12,y:ship.y+Math.sin(ship.a)*12,vx:Math.cos(ship.a)*250,vy:Math.sin(ship.a)*250}); });
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('load', ()=>{ fit(); spawnAsteroids(4); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- PAC-MAN (lite) -->
  <script>
  (function(){
    const canvas = document.getElementById('pacman-canvas'); if(!canvas) return; const ctx = canvas.getContext('2d');
    let gridSize=16, cols=10, rows=10, pac={x:1,y:1,dir:0}, pellets=[], ghosts=[], last=0, score=0;
    function fit(){ fitCanvasToWrapper(canvas); gridSize = Math.max(12, Math.floor(canvas.clientWidth/cols)); buildLevel(); }
    function buildLevel(){ pellets=[]; for(let y=0;y<rows;y++) for(let x=0;x<cols;x++) if(!(x===0||y===0||x===cols-1||y===rows-1)) pellets.push({x,y}); ghosts=[{x:cols-2,y:rows-2},{x:cols-2,y:1}]; }
    function update(dt){ // move ghosts randomly
      ghosts.forEach(g=>{ if(Math.random()<0.02) { const dirs=[[-1,0],[1,0],[0,-1],[0,1]]; const d=dirs[Math.floor(Math.random()*dirs.length)]; g.x=Math.max(1,Math.min(cols-2,g.x+d[0])); g.y=Math.max(1,Math.min(rows-2,g.y+d[1])); } });
      // pellet eat
      for(let i=pellets.length-1;i>=0;i--){ if(pellets[i].x===pac.x && pellets[i].y===pac.y){ pellets.splice(i,1); score+=10; document.getElementById('pacman-score').textContent=score; } }
    }
    function draw(){ fitCanvasToWrapper(canvas); const cell = Math.floor(canvas.clientWidth/cols); ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      // pellets
      ctx.fillStyle='#ffd166'; pellets.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x*cell+cell/2,p.y*cell+cell/2,3,0,Math.PI*2); ctx.fill(); });
      // pac
      ctx.fillStyle='#ffde59'; ctx.beginPath(); ctx.arc(pac.x*cell+cell/2,pac.y*cell+cell/2,cell*0.45,0,Math.PI*2); ctx.fill();
      // ghosts
      ghosts.forEach(g=>{ ctx.fillStyle='#ff6b6b'; ctx.fillRect(g.x*cell+4,g.y*cell+4,cell-8,cell-8); });
    }
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') pac.x=Math.max(1,pac.x-1); if(e.key==='ArrowRight') pac.x=Math.min(cols-2,pac.x+1); if(e.key==='ArrowUp') pac.y=Math.max(1,pac.y-1); if(e.key==='ArrowDown') pac.y=Math.min(rows-2,pac.y+1); });
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('load', ()=>{ fit(); buildLevel(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- FROGGER (mini) -->
  <script>
  (function(){
    const canvas = document.getElementById('frogger-canvas'); if(!canvas) return; const ctx = canvas.getContext('2d');
    let frog={x:0,y:0}, cars=[], last=0, level=1;
    function fit(){ fitCanvasToWrapper(canvas); frog.x = Math.floor(canvas.clientWidth/2); frog.y = canvas.clientHeight - 40; buildCars(); document.getElementById('frogger-level').textContent=level; }
    function buildCars(){ cars=[]; for(let r=0;r<4;r++){ for(let c=0;c<3;c++){ cars.push({x:Math.random()*canvas.clientWidth,y:60+r*40,w:60,h:24,spd:40 + r*20}); } } }
    function update(dt){ cars.forEach(c=>{ c.x += c.spd*dt; if(c.x>canvas.clientWidth+50) c.x=-100; if(Math.abs(c.x - frog.x) < 30 && Math.abs(c.y - frog.y) < 20) { frog.x = canvas.clientWidth/2; frog.y = canvas.clientHeight-40; level=1; document.getElementById('frogger-level').textContent=level; } if(frog.y < 40){ level++; document.getElementById('frogger-level').textContent=level; frog.x=canvas.clientWidth/2; frog.y=canvas.clientHeight-40; } }); }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); cars.forEach(c=>{ ctx.fillStyle='#ff8a5c'; ctx.fillRect(c.x,c.y,c.w,c.h); }); ctx.fillStyle='#2ecc71'; ctx.fillRect(frog.x-12,frog.y-12,24,24); }
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') frog.x -= 40; if(e.key==='ArrowRight') frog.x += 40; if(e.key==='ArrowUp') frog.y -= 40; if(e.key==='ArrowDown') frog.y += 40; });
    window.addEventListener('load', ()=>{ fit(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
  })();
  </script>

  <!-- BUBBLE SHOOTER (simple) -->
  <script>
  (function(){
    const canvas = document.getElementById('bubble-canvas'); if(!canvas) return; const ctx=canvas.getContext('2d');
    let bubbles=[], shooter={x:0,angle:Math.PI/2}, last=0, score=0;
    function fit(){ fitCanvasToWrapper(canvas); shooter.x = canvas.clientWidth/2; buildGrid(); }
    function buildGrid(){ bubbles=[]; const cols=8, rows=6; const cell=32; for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) bubbles.push({x:20+c*36,y:20+r*36,r:14,color: ['#ffd166','#ff6b6b','#2ecc71','#9b5cff'][Math.floor(Math.random()*4)]}); }
    function shoot(angle){ bubbles.push({x:shooter.x,y:canvas.clientHeight-30,vx:Math.cos(angle)*320,vy:Math.sin(angle)*-320,r:10,color:'#ffde59',player:true}); }
    function update(dt){ const all=bubbles; for(let b of all){ if(b.player){ b.x+=b.vx*dt; b.y+=b.vy*dt; for(let g of bubbles){ if(!g.player && Math.hypot(b.x-g.x,b.y-g.y) < b.r+g.r){ b.dead=true; g.dead=true; score+=10; document.getElementById('bubble-score').textContent=score; } } } } bubbles=bubbles.filter(b=>!b.dead && b.y> -50 && b.x>-50 && b.x<canvas.clientWidth+50); }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); bubbles.forEach(b=>{ ctx.beginPath(); ctx.fillStyle=b.color; ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }); // shooter
      ctx.fillStyle='#fff'; ctx.fillRect(shooter.x-20, canvas.clientHeight-28, 40, 10); }
    canvas.addEventListener('click', e=>{ const rect=canvas.getBoundingClientRect(); const ax = e.clientX-rect.left; const ay = e.clientY-rect.top; const ang = Math.atan2(ay - (canvas.clientHeight-30), ax - shooter.x); shoot(ang); });
    window.addEventListener('load', ()=>{ fit(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    document.getElementById('bubble-restart').addEventListener('click', ()=>{ score=0; document.getElementById('bubble-score').textContent=0; buildGrid(); });
  })();
  </script>

  <!-- RUNNER (endless) -->
  <script>
  (function(){
    const canvas = document.getElementById('runner-canvas'); if(!canvas) return; const ctx = canvas.getContext('2d');
    let player={x:50,y:0,vy:0,ground:0}, obstacles=[], speed=140, spawn=0, last=0, score=0;
    function fit(){ fitCanvasToWrapper(canvas); player.ground = canvas.clientHeight-40; player.y = player.ground; obstacles=[]; score=0; document.getElementById('runner-score').textContent=0; }
    function jump(){ if(player.y>=player.ground-1){ player.vy=-420; } }
    function update(dt){ player.vy += 1400*dt; player.y += player.vy*dt; if(player.y>player.ground) { player.y=player.ground; player.vy=0; } obstacles.forEach(o=>o.x -= speed*dt); spawn+=dt; if(spawn>1.2){ spawn=0; obstacles.push({x:canvas.clientWidth+20,y:player.ground-24,w:30,h:24}); } obstacles = obstacles.filter(o=>o.x+o.w> -20); obstacles.forEach(o=>{ if(Math.abs(o.x - player.x) < 24 && Math.abs(o.y - player.y) < 20){ // hit -> reset
        obstacles=[]; score=0; document.getElementById('runner-score').textContent=0;
      } if(o.x + o.w < player.x && !o.passed){ o.passed=true; score++; document.getElementById('runner-score').textContent=score; } }); }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); ctx.fillStyle='#fff'; ctx.fillRect(player.x-12,player.y-24,24,24); obstacles.forEach(o=>{ ctx.fillStyle='#ff8a5c'; ctx.fillRect(o.x,o.y,o.w,o.h); }); ctx.fillStyle='#6abf9f'; ctx.fillRect(0,canvas.clientHeight-40,canvas.clientWidth,40); }
    window.addEventListener('keydown', e=>{ if(e.key===' '||e.key==='ArrowUp') jump(); });
    document.getElementById('runner-restart').addEventListener('click', ()=>{ fit(); });
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('load', ()=>{ fit(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- final helper: resume CSS animations on user gesture -->
  <script>
  (function(){ function resume(){ document.documentElement.classList.add('user-gesture'); window.removeEventListener('keydown',resume); window.removeEventListener('pointerdown',resume); window.removeEventListener('touchstart',resume); } window.addEventListener('keydown',resume,{once:true}); window.addEventListener('pointerdown',resume,{once:true}); window.addEventListener('touchstart',resume,{once:true}); })();
  </script>

</body>
</html>
