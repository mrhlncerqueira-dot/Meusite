<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arcade â€” ColeÃ§Ã£o</title>
  <style>
    :root{
      --card-bg:#fff;
      --accent:#3f7bff;
      --page-pad:18px;
      --card-w:320px;
      --page-max:1400px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background:linear-gradient(120deg,#eef6ff,#fbfcff);
      color:#13202a;
      padding:var(--page-pad);
      -webkit-font-smoothing:antialiased;
    }

    .site-title{ text-align:center; font-weight:800; margin:0 0 18px; }
    .site-title .animated-text{ display:inline-block; animation: colorCycle 3s linear infinite, blink 1s ease-in-out infinite; }
    @keyframes colorCycle{0%{color:#2ecc71}33%{color:#ff6b6b}66%{color:#ffd166}100%{color:#2ecc71}}
    @keyframes blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}
    @media (prefers-reduced-motion:reduce){ .site-title .animated-text{ animation:none; color:#2ecc71 } }

    .games-row{
      display:flex; flex-wrap:wrap; gap:18px;
      justify-content:center; max-width:var(--page-max); margin:0 auto;
    }

    /* FIXES: avoid excessive white space under cards and keep canvases from stretching */
    .game-card{
      flex:0 0 var(--card-w); width:var(--card-w);
      background:var(--card-bg); border-radius:12px;
      box-shadow:0 10px 28px rgba(16,24,40,0.06); overflow:hidden;
      display:flex; flex-direction:column;
      min-height: 0;
    }
    .game-card h2{ font-size:1rem; margin:12px; text-align:center; }
    .game-card__body{
      padding:10px; display:flex; flex-direction:column; gap:8px; align-items:stretch; min-height: 0;
    }

    /* Container for the interactive area: reasonable min/max height to avoid huge blank areas */
    .game-inner{
      flex: 0 0 auto;
      width:100%;
      min-height: 160px;
      max-height: 420px;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:8px;
      box-sizing:border-box;
    }

    /* Ensure canvas doesn't stretch vertically beyond its container and scales nicely */
    .game-inner canvas {
      width: 100% !important;
      height: auto !important;
      max-height: 100%;
      display: block;
      background: #0b0b0b;
      border-radius: 8px;
    }

    .controls{ display:flex; gap:8px; justify-content:center; margin-top:6px; }
    .btn{ background:var(--accent); color:#fff; border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:700; }
    .small-note{ font-size:12px; text-align:center; color:#536370; }

    /* grid/board helpers */
    #mem-board{ display:grid; gap:8px; justify-content:center; width:100%; }
    .cell{ border-radius:8px; background:#56606a; width:56px; height:56px; display:flex; align-items:center; justify-content:center; color:transparent; font-size:22px; box-shadow:0 6px 14px rgba(10,20,40,0.05); }
    .cell.open{ background:#fff; color:#111; transform:scale(1.03) }
    .cell.matched{ background:#dff7e7; color:#0b5132 }

    /* Simon */
    .simon-grid{ display:grid; grid-template-columns:1fr 1fr; grid-template-rows:1fr 1fr; gap:10px; width:100%; height:100%; }
    .simon-pad{ border-radius:12px; display:flex; align-items:center; justify-content:center; font-weight:800; color:#111; user-select:none; }

    @media (max-width:960px){
      .game-card{ flex:1 1 92%; width:auto; }
      .site-title{ font-size:1.2rem; }
    }

    /* Small helper to make boards look centred when short */
    .game-card__body > .controls { margin-top: auto; }

  </style>
</head>
<body>

  <h1 class="site-title" role="heading" aria-level="1">
    <span class="animated-text">Jogue aqui os jogos arcade mais desejados de todos os tempos</span>
  </h1>

  <div class="games-row">

    <!-- TETRIS -->
    <div class="game-card" id="tetris-card"><h2>Tetris</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="tetris-score">0</span></div><div>NÃ­vel: <span id="tetris-level">1</span></div></div>
        <div class="game-inner"><canvas id="tetris-canvas" data-cols="10" data-rows="20"></canvas></div>
        <div class="controls"><button id="tetris-restart" class="btn">Reiniciar</button><button id="tetris-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <!-- MEMORY -->
    <div class="game-card" id="mem-card"><h2>Memory</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:8px;font-weight:700"><div>NÃ­vel: <span id="mem-lvl">1</span></div><div>Mov.: <span id="mem-moves">0</span></div></div>
        <div class="game-inner"><div id="mem-board" aria-live="polite" style="width:100%;"></div></div>
        <div class="controls"><button id="mem-restart" class="btn">Reiniciar</button><button id="mem-next" class="btn" disabled>PrÃ³x</button></div>
      </div>
    </div>

    <!-- PONG -->
    <div class="game-card" id="pong-card"><h2>Pong</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>A: <span id="pong-score-a">0</span></div><div>B: <span id="pong-score-b">0</span></div></div>
        <div class="game-inner"><canvas id="pong-canvas"></canvas></div>
        <div class="controls"><button id="pong-restart" class="btn">Reiniciar</button><button id="pong-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <!-- SIMON -->
    <div class="game-card" id="simon-card"><h2>Simon</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>NÃ­vel: <span id="simon-level">0</span></div><div>Recorde: <span id="simon-best">0</span></div></div>
        <div class="game-inner"><div class="simon-grid" id="simon-grid">
          <div class="simon-pad" id="pad-0" style="background:#2ecc71"></div>
          <div class="simon-pad" id="pad-1" style="background:#ffd166"></div>
          <div class="simon-pad" id="pad-2" style="background:#ff6b6b"></div>
          <div class="simon-pad" id="pad-3" style="background:#9b5cff"></div>
        </div></div>
        <div class="controls"><button id="simon-start" class="btn">Start</button><button id="simon-strict" class="btn">Strict</button></div>
      </div>
    </div>

    <!-- FLAPPY -->
    <div class="game-card" id="flappy-card"><h2>Flappy</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="flappy-score">0</span></div><div>Best: <span id="flappy-best">0</span></div></div>
        <div class="game-inner"><canvas id="flappy-canvas" style="background:#70c5ce"></canvas></div>
        <div class="controls"><button id="flappy-restart" class="btn">Reiniciar</button><button id="flappy-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <!-- SNAKE -->
    <div class="game-card" id="snake-card"><h2>Snake</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="snake-score">0</span></div></div>
        <div class="game-inner"><canvas id="snake-canvas"></canvas></div>
        <div class="controls"><button id="snake-restart" class="btn">Reiniciar</button><button id="snake-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <!-- BREAKOUT -->
    <div class="game-card" id="breakout-card"><h2>Breakout</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="breakout-score">0</span></div></div>
        <div class="game-inner"><canvas id="breakout-canvas"></canvas></div>
        <div class="controls"><button id="breakout-restart" class="btn">Reiniciar</button><button id="breakout-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <!-- SPACE INVADERS -->
    <div class="game-card" id="invaders-card"><h2>Space Invaders</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="invaders-score">0</span></div></div>
        <div class="game-inner"><canvas id="invaders-canvas"></canvas></div>
        <div class="controls"><button id="invaders-restart" class="btn">Reiniciar</button><button id="invaders-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <!-- ASTEROIDS -->
    <div class="game-card" id="asteroids-card"><h2>Asteroids</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="asteroids-score">0</span></div></div>
        <div class="game-inner"><canvas id="asteroids-canvas"></canvas></div>
        <div class="controls"><button id="asteroids-restart" class="btn">Reiniciar</button><button id="asteroids-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <!-- PAC-MAN (lite) -->
    <div class="game-card" id="pacman-card"><h2>Pacâ€‘Man (lite)</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="pacman-score">0</span></div></div>
        <div class="game-inner"><canvas id="pacman-canvas"></canvas></div>
        <div class="controls"><button id="pacman-restart" class="btn">Reiniciar</button><button id="pacman-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <!-- FROGGER -->
    <div class="game-card" id="frogger-card"><h2>Frogger</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Level: <span id="frogger-level">1</span></div></div>
        <div class="game-inner"><canvas id="frogger-canvas"></canvas></div>
        <div class="controls"><button id="frogger-restart" class="btn">Reiniciar</button></div>
      </div>
    </div>

    <!-- BUBBLE SHOOTER -->
    <div class="game-card" id="bubble-card"><h2>Bubble Shooter</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="bubble-score">0</span></div></div>
        <div class="game-inner"><canvas id="bubble-canvas"></canvas></div>
        <div class="controls"><button id="bubble-restart" class="btn">Reiniciar</button></div>
      </div>
    </div>

    <!-- RUNNER -->
    <div class="game-card" id="runner-card"><h2>Endless Runner</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="runner-score">0</span></div></div>
        <div class="game-inner"><canvas id="runner-canvas"></canvas></div>
        <div class="controls"><button id="runner-restart" class="btn">Reiniciar</button></div>
      </div>
    </div>

    <!-- BATTLESHIP (new) -->
    <div class="game-card" id="battleship-card"><h2>Batalha Naval</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:8px;font-weight:700"><div>Tu vs IA (Hunt & Target)</div></div>
        <div class="game-inner" style="min-height:260px;">
          <div id="battleship-root" style="width:100%;display:flex;gap:8px;align-items:flex-start;justify-content:center;flex-wrap:wrap">
            <div style="text-align:center">
              <div style="font-weight:700;margin-bottom:6px">Teu Tabuleiro</div>
              <canvas id="battleship-player" style="background:#fff;border-radius:6px;"></canvas>
            </div>
            <div style="text-align:center">
              <div style="font-weight:700;margin-bottom:6px">Tabuleiro IA (clicar para atacar)</div>
              <canvas id="battleship-ai" style="background:#fff;border-radius:6px;"></canvas>
            </div>
          </div>
        </div>
        <div class="controls"><button id="battleship-restart" class="btn">Reiniciar</button><button id="battleship-auto" class="btn">Auto colocar</button></div>
      </div>
    </div>

    <!-- VERTICAL SHOOTER (new) -->
    <div class="game-card" id="shooter-card"><h2>Vertical Shooter</h2>
      <div class="game-card__body">
        <div style="display:flex;justify-content:center;gap:10px;font-weight:700"><div>Pontos: <span id="shooter-score">0</span></div></div>
        <div class="game-inner"><canvas id="shooter-canvas" style="background:#041628"></canvas></div>
        <div class="controls"><button id="shooter-restart" class="btn">Reiniciar</button><button id="shooter-pause" class="btn">Pausar</button></div>
      </div>
    </div>

  </div>

  <!-- ================= SCRIPTS: helper utilities (shared) ================= -->
  <script>
  // Fit canvas to its wrapper with DPR. Safe, used by all games.
  function fitCanvasToWrapper(canvas){
    if(!canvas) return false;
    const dpr = window.devicePixelRatio || 1;
    const wrap = canvas.closest('.game-inner') || canvas.parentElement || document.body;
    const rect = wrap.getBoundingClientRect();
    const w = Math.max(80, Math.floor(rect.width));
    const h = Math.max(80, Math.floor(rect.height));
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    const rw = Math.floor(w * dpr), rh = Math.floor(h * dpr);
    if(canvas.width !== rw || canvas.height !== rh){
      canvas.width = rw; canvas.height = rh;
      const ctx = canvas.getContext('2d');
      if(ctx && ctx.setTransform) ctx.setTransform(dpr,0,0,dpr,0,0);
      return true;
    }
    return false;
  }

  // Resize all canvases when viewport changes
  function fitAllCanvases(){
    document.querySelectorAll('canvas').forEach(c => {
      try{ fitCanvasToWrapper(c); }catch(e){}
    });
  }
  window.addEventListener('resize', ()=>{ clearTimeout(window._fitTimer); window._fitTimer = setTimeout(fitAllCanvases, 90); });
  window.addEventListener('load', ()=>{ setTimeout(fitAllCanvases, 140); });

  // Helper: clamp
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  </script>

  <!-- ================= GAMES: simplified but functional implementations ================= -->
  <!-- For brevity the games are concise but functional. If queres ajustes (difficulty, touch controls etc.) eu adapto. -->

  <!-- TETRIS (compact & functional) -->
  <script>
  (function(){
    const canvas = document.getElementById('tetris-canvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('tetris-score');
    const levelEl = document.getElementById('tetris-level');
    const restartBtn = document.getElementById('tetris-restart');
    const pauseBtn = document.getElementById('tetris-pause');
    fitCanvasToWrapper(canvas);

    const COLS = 10, ROWS = 20;
    const SHAPES = { I:[[1,1,1,1]], O:[[1,1],[1,1]], T:[[0,1,0],[1,1,1]], S:[[0,1,1],[1,1,0]], Z:[[1,1,0],[0,1,1]], J:[[1,0,0],[1,1,1]], L:[[0,0,1],[1,1,1]] };
    const COLORS = { I:'#00d2ff',O:'#ffd86b',T:'#9b5cff',S:'#2ecc71',Z:'#ff6b6b',J:'#ff8a5c',L:'#ffd166' };
    function rotate(m){ const a=Array.from({length:m[0].length},()=>[]); for(let r=0;r<m.length;r++) for(let c=0;c<m[r].length;c++) a[c][m.length-1-r]=m[r][c]; return a; }
    function generateRotations(shape){ let r = shape.map(s=>s.slice()), res=[r]; for(let i=0;i<3;i++){ r = rotate(r); if(!res.some(x=>JSON.stringify(x)===JSON.stringify(r))) res.push(r); } return res; }
    const PIECES = {}; for(let k in SHAPES) PIECES[k]=generateRotations(SHAPES[k]);

    let board = [], piece = null, queue = [], score = 0, level = 1, lines = 0, acc = 0, last = 0, paused=false;

    function createBoard(){ board = Array.from({length:ROWS},()=>Array(COLS).fill(0)); }
    function fillBag(){ let bag = Object.keys(PIECES).slice(); for(let i=bag.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]];} queue.push(...bag); }
    function spawn(){ if(queue.length<3) fillBag(); const type = queue.shift(); piece = { type, rot:0, x: Math.floor((COLS - PIECES[type][0][0].length)/2), y: -PIECES[type][0].length }; if(collision(piece,0,0,piece.rot)) paused = true; }
    function collision(p,dx,dy,rot){ const mat = PIECES[p.type][rot]; for(let r=0;r<mat.length;r++) for(let c=0;c<mat[r].length;c++) if(mat[r][c]){ const nx=p.x+c+dx, ny=p.y+r+dy; if(nx<0||nx>=COLS) return true; if(ny>=ROWS) return true; if(ny>=0 && board[ny][nx]) return true; } return false; }
    function lock(){ const mat=PIECES[piece.type][piece.rot]; for(let r=0;r<mat.length;r++) for(let c=0;c<mat[r].length;c++) if(mat[r][c]){ const nx=piece.x+c, ny=piece.y+r; if(ny>=0) board[ny][nx]=piece.type; } clearLines(); spawn(); }
    function clearLines(){ let removed=0; for(let r=ROWS-1;r>=0;r--){ if(board[r].every(v=>v)){ board.splice(r,1); board.unshift(Array(COLS).fill(0)); removed++; r++; } } if(removed){ lines+=removed; score += [0,40,100,300,1200][removed]*level; level=Math.floor(lines/10)+1; scoreEl.textContent=score; levelEl.textContent=level; } }
    function move(dx){ if(!piece || paused) return; if(!collision(piece,dx,0,piece.rot)) piece.x+=dx; }
    function rotatePiece(){ if(!piece || paused) return; const next=(piece.rot+1)%PIECES[piece.type].length; const kicks=[0,-1,1,-2,2]; for(let k of kicks) if(!collision(piece,k,0,next)){ piece.x+=k; piece.rot = next; break; } }
    function softDrop(){ if(!piece || paused) return false; if(!collision(piece,0,1,piece.rot)){ piece.y++; return true; } else { if(piece.y < 0) paused = true; else lock(); return false; } }
    function hardDrop(){ if(!piece || paused) return; while(!collision(piece,0,1,piece.rot)) { piece.y++; score+=2; } lock(); scoreEl.textContent=score; }

    window.addEventListener('keydown', e=>{
      if(e.key==='ArrowLeft') move(-1);
      if(e.key==='ArrowRight') move(1);
      if(e.key==='ArrowUp') rotatePiece();
      if(e.key==='ArrowDown'){ softDrop(); score++; scoreEl.textContent=score; }
      if(e.key===' ') hardDrop();
      if(e.key==='p' || e.key==='P'){ paused=!paused; pauseBtn.textContent = paused ? 'Retomar':'Pausar'; }
    });
    restartBtn.addEventListener('click', ()=>init(true));
    pauseBtn.addEventListener('click', ()=>{ paused=!paused; pauseBtn.textContent = paused ? 'Retomar':'Pausar'; });

    function draw(){
      fitCanvasToWrapper(canvas);
      const cell = Math.floor(canvas.clientWidth / COLS);
      const offX = Math.floor((canvas.clientWidth - cell*COLS)/2);
      const offY = Math.floor((canvas.clientHeight - cell*ROWS)/2);
      ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        const x=offX+c*cell, y=offY+r*cell;
        ctx.fillStyle='#101115'; ctx.fillRect(x,y,cell,cell);
        if(board[r][c]){ ctx.fillStyle = COLORS[board[r][c]] || '#999'; ctx.fillRect(x+2,y+2,cell-4,cell-4); ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.strokeRect(x+2,y+2,cell-4,cell-4); }
      }
      if(piece){
        let mat = PIECES[piece.type][piece.rot];
        for(let r=0;r<mat.length;r++) for(let c=0;c<mat[r].length;c++) if(mat[r][c]){
          const x=offX+(piece.x+c)*cell, y=offY+(piece.y+r)*cell;
          if(y+cell < offY) continue;
          ctx.fillStyle = COLORS[piece.type]; ctx.fillRect(x+2,y+2,cell-4,cell-4);
        }
      }
    }

    function loop(ts){
      if(!last) last=ts;
      const dt = ts - last; last = ts;
      if(!paused){ acc += dt; const interval = Math.max(120, 800 - (level-1)*60); while(acc >= interval){ softDrop(); acc -= interval; } }
      draw();
      requestAnimationFrame(loop);
    }

    function init(full){
      createBoard(); queue=[]; if(full) fillBag(); spawn(); score=0; level=1; lines=0; acc=0; last=0; paused=false;
      scoreEl.textContent=0; levelEl.textContent=1;
    }
    init(true); requestAnimationFrame(loop);
    window.addEventListener('resize', ()=>fitCanvasToWrapper(canvas));
  })();
  </script>

  <!-- MEMORY (compact) -->
  <script>
  (function(){
    const boardEl = document.getElementById('mem-board'), movesEl=document.getElementById('mem-moves'),
          scoreEl=document.getElementById('mem-score'), lvlEl=document.getElementById('mem-lvl'),
          restartBtn=document.getElementById('mem-restart'), nextBtn=document.getElementById('mem-next');
    const SYMBOLS=['ðŸŽ','ðŸ‹','ðŸ‡','ðŸ“','ðŸ‰','ðŸ’','ðŸŠ','ðŸ¥','ðŸ','ðŸ¥‘','ðŸ‘','ðŸŒ','ðŸ','ðŸˆ','ðŸ¥¥','ðŸ'];
    let level=0, rows=4, cols=4, board=[], first=null, second=null, lock=false, moves=0, score=0, matches=0;
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
    function setGrid(){
      const pairs = (rows*cols)/2;
      const pool = shuffle(SYMBOLS.slice());
      const chosen = pool.slice(0,pairs);
      const symbols = shuffle([...chosen, ...chosen]);
      board = symbols.map((s,i)=>({id:i,symbol:s,matched:false}));
      const cellSize = Math.max(40, Math.min(80, Math.floor((document.querySelector('#mem-card .game-inner').clientWidth - 20)/cols)));
      boardEl.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
      boardEl.innerHTML='';
      board.forEach(c=>{
        const b=document.createElement('button'); b.className='cell'; b.dataset.id=c.id; b.style.width=cellSize+'px'; b.style.height=cellSize+'px';
        b.innerHTML='<span></span>'; b.addEventListener('click', onClick); boardEl.appendChild(b);
      });
    }
    function build(){
      const sizes=[{r:2,c:2},{r:2,c:3},{r:3,c:4},{r:4,c:4},{r:4,c:5}];
      const spec = level<sizes.length ? sizes[level] : {r:Math.min(8,4+Math.floor((level-sizes.length)/2)), c:Math.min(8,5+((level-sizes.length)%2))};
      rows=spec.r; cols=spec.c; setGrid(); first=second=null; lock=false; moves=0; score=0; matches=0;
      movesEl && (movesEl.textContent = moves); scoreEl && (scoreEl.textContent = score); lvlEl && (lvlEl.textContent = level+1);
      nextBtn && (nextBtn.disabled = true);
    }
    function openCard(el,card){ el.classList.add('open'); el.querySelector('span').textContent = card.symbol; }
    function closeCard(el){ el.classList.remove('open'); el.querySelector('span').textContent = ''; }
    function onClick(e){
      if(lock) return; const el=e.currentTarget; const id=+el.dataset.id; const card=board[id]; if(card.matched) return; if(first && first.id===id) return;
      openCard(el,card);
      if(!first){ first={id,el,card}; return; }
      second={id,el,card}; moves++; movesEl.textContent=moves; lock=true;
      if(first.card.symbol === second.card.symbol){
        setTimeout(()=>{ first.card.matched = second.card.matched = true; first.el.classList.add('matched'); second.el.classList.add('matched'); matches++; score+=10; scoreEl.textContent=score; first=second=null; lock=false; checkWin(); }, 300);
      } else {
        setTimeout(()=>{ closeCard(first.el); closeCard(second.el); score=Math.max(0,score-1); scoreEl.textContent=score; first=second=null; lock=false; }, 700);
      }
    }
    function checkWin(){ if(matches === (rows*cols)/2){ nextBtn && (nextBtn.disabled = false); } }
    restartBtn && restartBtn.addEventListener('click', build);
    nextBtn && nextBtn.addEventListener('click', ()=>{ level++; build(); });
    window.addEventListener('resize', ()=>{ setTimeout(()=>setGrid(),120); });
    build();
  })();
  </script>

  <!-- PONG (compact) -->
  <script>
  (function(){
    const canvas = document.getElementById('pong-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d'); fitCanvasToWrapper(canvas);
    let left={y:0,vy:0,score:0}, right={y:0,vy:0,score:0}, paddleW=8,paddleH=80,ball={x:0,y:0,vx:120,vy:20}, last=0, paused=false;
    function resize(){ fitCanvasToWrapper(canvas); const w=canvas.clientWidth,h=canvas.clientHeight; paddleH=Math.max(40,h*0.18); paddleW=Math.max(6,w*0.02); left.y=right.y=(h-paddleH)/2; ball.x=w/2; ball.y=h/2; }
    function resetBall(dir){ ball.x=canvas.clientWidth/2; ball.y=canvas.clientHeight/2; ball.vx = 120 * (dir|| (Math.random()<0.5?1:-1)); ball.vy = (Math.random()-0.5)*140; }
    function update(dt){
      if(paused) return;
      left.y = clamp(left.y + left.vy*dt, 0, canvas.clientHeight-paddleH);
      right.y = clamp(right.y + right.vy*dt, 0, canvas.clientHeight-paddleH);
      ball.x += ball.vx*dt; ball.y += ball.vy*dt;
      if(ball.y < 6 || ball.y > canvas.clientHeight-6) ball.vy = -ball.vy;
      if(ball.x < 0){ right.score++; document.getElementById('pong-score-b').textContent = right.score; resetBall(1); }
      if(ball.x > canvas.clientWidth){ left.score++; document.getElementById('pong-score-a').textContent = left.score; resetBall(-1); }
      // collisions
      if(ball.x - 8 < 12 + paddleW && ball.y > left.y && ball.y < left.y + paddleH) { ball.vx = Math.abs(ball.vx); }
      if(ball.x + 8 > canvas.clientWidth - (12 + paddleW) && ball.y > right.y && ball.y < right.y + paddleH) { ball.vx = -Math.abs(ball.vx); }
    }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); ctx.fillStyle='rgba(255,255,255,0.06)'; for(let y=0;y<canvas.clientHeight;y+=24) ctx.fillRect(canvas.clientWidth/2-1,y+6,2,12);
      ctx.fillStyle='#fff'; ctx.fillRect(12,left.y,paddleW,paddleH); ctx.fillRect(canvas.clientWidth-12-paddleW,right.y,paddleW,paddleH); ctx.beginPath(); ctx.fillStyle='#ff7b7b'; ctx.arc(ball.x,ball.y,8,0,Math.PI*2); ctx.fill(); }
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('keydown', e=>{ if(e.key==='w') left.vy=-160; if(e.key==='s') left.vy=160; if(e.key==='ArrowUp') right.vy=-160; if(e.key==='ArrowDown') right.vy=160; if(e.key==='p'){ paused=!paused; document.getElementById('pong-pause').textContent=paused?'Retomar':'Pausar'; }});
    window.addEventListener('keyup', e=>{ if(e.key==='w'||e.key==='s') left.vy=0; if(e.key==='ArrowUp'||e.key==='ArrowDown') right.vy=0; });
    document.getElementById('pong-restart').addEventListener('click', ()=>{ left.score=right.score=0; document.getElementById('pong-score-a').textContent=0; document.getElementById('pong-score-b').textContent=0; resetBall(1); paused=false; });
    document.getElementById('pong-pause').addEventListener('click', ()=>{ paused=!paused; document.getElementById('pong-pause').textContent=paused?'Retomar':'Pausar'; });
    window.addEventListener('resize', ()=>resize()); window.addEventListener('load', ()=>{ resize(); resetBall(1); requestAnimationFrame(loop); });
  })();
  </script>

  <!-- SIMON (improved) -->
  <script>
  (function(){
    const pads = Array.from(document.querySelectorAll('#simon-grid .simon-pad')); if(!pads.length) return;
    const startBtn = document.getElementById('simon-start'), strictBtn = document.getElementById('simon-strict');
    const levelEl = document.getElementById('simon-level'), bestEl = document.getElementById('simon-best');
    const aCtx = window.AudioContext? new AudioContext():null; const freqs=[440,523.25,659.25,349.23];
    let seq=[], idx=0, playing=false, busy=false, strict=false, best=Number(localStorage.getItem('simon-best')||0);
    bestEl.textContent=best;
    function tone(i,d=300){ if(!aCtx) return; try{ const o=aCtx.createOscillator(), g=aCtx.createGain(); o.frequency.value=freqs[i]; o.connect(g); g.connect(aCtx.destination); g.gain.setValueAtTime(0.001,aCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.12,aCtx.currentTime+0.02); o.start(); g.gain.exponentialRampToValueAtTime(0.001,aCtx.currentTime+d/1000); o.stop(aCtx.currentTime+d/1000+0.02); }catch(e){} }
    function flash(i,ms=300){ return new Promise(r=>{ const p=pads[i]; p.classList.add('active'); tone(i,ms); setTimeout(()=>{ p.classList.remove('active'); setTimeout(r,120); },ms); }); }
    async function playSeq(){ busy=true; for(let v of seq){ await flash(v, Math.max(180,400-seq.length*6)); } busy=false; }
    function nextRound(){ seq.push(Math.floor(Math.random()*4)); levelEl.textContent=seq.length; if(seq.length>best){ best=seq.length; localStorage.setItem('simon-best',best); bestEl.textContent=best; } playSeq().then(()=>{ idx=0; playing=true; }); }
    function reset(){ seq=[]; idx=0; playing=false; busy=false; levelEl.textContent=0; }
    pads.forEach((p,i)=>{ p.classList.add('dim'); function tryPress(){ if(busy) return; if(!playing) return; flash(i,160); if(seq[idx]===i){ idx++; if(idx>=seq.length){ playing=false; setTimeout(()=>nextRound(),420); } } else { busy=true; pads.forEach(x=>x.classList.add('dim')); if(aCtx){ try{ const o=aCtx.createOscillator(); const g=aCtx.createGain(); o.frequency.value=120; o.connect(g); g.connect(aCtx.destination); g.gain.value=0.08; o.start(); setTimeout(()=>o.stop(),300);}catch(e){} } setTimeout(async ()=>{ pads.forEach(x=>x.classList.remove('dim')); busy=false; if(strict){ reset(); start(); } else { idx=0; await playSeq(); playing=true; } },500); } } p.addEventListener('click', ()=>{ if(aCtx && aCtx.state==='suspended') aCtx.resume(); tryPress(); }); p.addEventListener('touchstart', e=>{ e.preventDefault(); if(aCtx && aCtx.state==='suspended') aCtx.resume(); tryPress(); },{passive:false}); });
    function start(){ if(aCtx && aCtx.state==='suspended') aCtx.resume(); reset(); setTimeout(()=>nextRound(),180); }
    startBtn.addEventListener('click', start); strictBtn.addEventListener('click', ()=>{ strict=!strict; strictBtn.style.opacity = strict? '1':'0.6'; });
  })();
  </script>

  <!-- FLAPPY (improved drawing) -->
  <script>
  (function(){
    const canvas = document.getElementById('flappy-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d'); const scoreEl = document.getElementById('flappy-score'), bestEl = document.getElementById('flappy-best');
    let best = Number(localStorage.getItem('flappy-best')||0); bestEl.textContent=best;
    function fit(){ fitCanvasToWrapper(canvas); }
    let bird={x:60,y:120,vy:0,r:12}, pipes=[], gravity=900, flap=-340, spawnT=0, spawnI=1.5, speed=120, last=0, score=0, running=false, paused=false;
    function reset(){ fit(); const w=canvas.clientWidth,h=canvas.clientHeight; bird.x=Math.max(40,w*0.18); bird.y=h/2; bird.vy=0; bird.r=Math.max(8,Math.min(18,Math.floor(h*0.035))); pipes=[]; spawnT=0; score=0; running=true; paused=false; scoreEl.textContent=0; }
    function spawn(){ const w=canvas.clientWidth,h=canvas.clientHeight; const gap=Math.max(70,Math.floor(h*0.22)); const gapY=Math.floor(60+Math.random()*(h-140-gap)); pipes.push({x:w+20,gapY,wid:Math.max(46,Math.floor(w*0.14)),gapH:gap,passed:false}); }
    function flapFn(){ if(!running){ reset(); last=performance.now(); requestAnimationFrame(loop); return; } bird.vy=flap; }
    function step(dt){ if(paused||!running) return; bird.vy+=gravity*dt; bird.y+=bird.vy*dt; pipes.forEach(p=>p.x-=speed*dt); spawnT+=dt; if(spawnT>=spawnI){ spawnT=0; spawn(); } if(pipes.length && pipes[0].x + pipes[0].wid < -30) pipes.shift(); const h=canvas.clientHeight; if(bird.y-bird.r<=0||bird.y+bird.r>=h-40) running=false; for(let p of pipes){ if(!p.passed && p.x + p.wid < bird.x){ p.passed=true; score++; scoreEl.textContent=score; if(score>best){ best=score; localStorage.setItem('flappy-best',best); bestEl.textContent=best; } } if(bird.x+bird.r>p.x && bird.x-bird.r<p.x+p.wid){ if(bird.y-bird.r < p.gapY || bird.y+bird.r > p.gapY + p.gapH) running=false; } } }
    function drawBird(x,y,r){ ctx.beginPath(); ctx.fillStyle='#ffde59'; ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle='#111'; ctx.arc(x + r*0.35, y - r*0.25, Math.max(1.4, r*0.18),0,Math.PI*2); ctx.fill(); ctx.fillStyle='#ff8a2f'; ctx.beginPath(); ctx.moveTo(x + r, y); ctx.lineTo(x + r + r*0.9, y - r*0.35); ctx.lineTo(x + r + r*0.9, y + r*0.35); ctx.closePath(); ctx.fill(); }
    function draw(){ const w=canvas.clientWidth,h=canvas.clientHeight; ctx.fillStyle='#70c5ce'; ctx.fillRect(0,0,w,h); ctx.fillStyle='#6abf9f'; ctx.fillRect(0,h-40,w,40); for(let p of pipes){ ctx.fillStyle='#2d8a57'; ctx.fillRect(p.x,0,p.wid,p.gapY); ctx.fillRect(p.x,p.gapY+p.gapH,p.wid,h-(p.gapY+p.gapH)-40); ctx.fillStyle='#1f5f3f'; ctx.fillRect(p.x,p.gapY-6,p.wid,6); ctx.fillRect(p.x,p.gapY+p.gapH,p.wid,6); } drawBird(bird.x,bird.y,bird.r); }
    function loop(ts){ if(!last) last=ts; const dt=Math.min(0.05,(ts-last)/1000); last=ts; step(dt); draw(); requestAnimationFrame(loop); }
    canvas.addEventListener('click', ()=>flapFn()); canvas.addEventListener('touchstart', e=>{ e.preventDefault(); flapFn(); },{passive:false});
    document.getElementById('flappy-restart').addEventListener('click', ()=>{ reset(); last=performance.now(); requestAnimationFrame(loop); });
    document.getElementById('flappy-pause').addEventListener('click', ()=>{ paused=!paused; document.getElementById('flappy-pause').textContent=paused?'Retomar':'Pausar'; });
    window.addEventListener('load', ()=>{ fit(); reset(); last=performance.now(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- SNAKE -->
  <script>
  (function(){
    const canvas = document.getElementById('snake-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d'); fitCanvasToWrapper(canvas);
    let grid=18, snake=[], dir={x:1,y:0}, food={x:8,y:8}, last=0, speed=8, score=0, running=true, paused=false;
    function fit(){ fitCanvasToWrapper(canvas); grid=Math.max(8, Math.floor(canvas.clientWidth/18)); }
    function reset(){ fit(); snake=[{x:5,y:5},{x:4,y:5},{x:3,y:5}]; dir={x:1,y:0}; placeFood(); score=0; document.getElementById('snake-score').textContent=0; running=true; }
    function placeFood(){ const cols = Math.floor(canvas.clientWidth / grid), rows = Math.floor(canvas.clientHeight / grid); food.x = Math.floor(Math.random()*cols); food.y = Math.floor(Math.random()*rows); }
    function update(){ const head={x:snake[0].x+dir.x, y:snake[0].y+dir.y}; const cols = Math.floor(canvas.clientWidth / grid), rows = Math.floor(canvas.clientHeight / grid);
      if(head.x<0) head.x = cols-1; if(head.x>=cols) head.x=0; if(head.y<0) head.y = rows-1; if(head.y>=rows) head.y=0;
      if(snake.some(s=>s.x===head.x&&s.y===head.y)){ running=false; return; }
      snake.unshift(head);
      if(head.x===food.x && head.y===food.y){ score+=10; document.getElementById('snake-score').textContent=score; placeFood(); } else snake.pop();
    }
    function draw(){ fitCanvasToWrapper(canvas); const cell = Math.max(6, Math.floor(canvas.clientWidth / Math.floor(canvas.clientWidth/grid))); ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      ctx.fillStyle='#2ecc71'; snake.forEach((s,i)=>{ ctx.fillRect(s.x*cell, s.y*cell, cell-1, cell-1); });
      ctx.fillStyle='#ff6b6b'; ctx.fillRect(food.x*cell, food.y*cell, cell-1, cell-1);
    }
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; if(!paused && running){ if(dt>1/speed){ update(); last=ts; } } draw(); requestAnimationFrame(loop); }
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowUp' && dir.y!==1) dir={x:0,y:-1}; if(e.key==='ArrowDown' && dir.y!==-1) dir={x:0,y:1}; if(e.key==='ArrowLeft' && dir.x!==1) dir={x:-1,y:0}; if(e.key==='ArrowRight' && dir.x!==-1) dir={x:1,y:0}; if(e.key==='p'){ paused=!paused; document.getElementById('snake-pause').textContent=paused?'Retomar':'Pausar'; }});
    document.getElementById('snake-restart').addEventListener('click', ()=>reset()); document.getElementById('snake-pause').addEventListener('click', ()=>{ paused=!paused; document.getElementById('snake-pause').textContent=paused?'Retomar':'Pausar'; });
    window.addEventListener('load', ()=>{ fit(); reset(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- BREAKOUT (simple) -->
  <script>
  (function(){
    const canvas = document.getElementById('breakout-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d'); fitCanvasToWrapper(canvas);
    let paddle={w:80,h:12,x:0}, ball={x:0,y:0,vx:140,vy:-140,r:8}, bricks=[], rows=4, cols=6, last=0, score=0, paused=false;
    function fit(){ fitCanvasToWrapper(canvas); const cw=canvas.clientWidth; paddle.w=Math.max(60,Math.floor(cw*0.25)); paddle.x=(cw-paddle.w)/2; ball.x=cw/2; ball.y=canvas.clientHeight-60; }
    function buildBricks(){ bricks=[]; const cw=canvas.clientWidth; const cellW=Math.floor((cw-20)/cols); for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) bricks.push({x:10+c*(cellW+4), y:20+r*22, w:cellW, h:18, alive:true}); }
    function update(dt){ if(paused) return; ball.x+=ball.vx*dt; ball.y+=ball.vy*dt; if(ball.x-ball.r<0||ball.x+ball.r>canvas.clientWidth) ball.vx=-ball.vx; if(ball.y-ball.r<0) ball.vy=-ball.vy; if(ball.y+ball.r>canvas.clientHeight){ ball.x=canvas.clientWidth/2; ball.y=canvas.clientHeight-60; ball.vy=-140; score=0; document.getElementById('breakout-score').textContent=score; }
      if(ball.x>paddle.x && ball.x<paddle.x+paddle.w && ball.y+ball.r >= canvas.clientHeight-40) { ball.vy = -Math.abs(ball.vy); ball.vx *= 1.02; }
      bricks.forEach(b=>{ if(b.alive && ball.x>b.x && ball.x<b.x+b.w && ball.y>b.y && ball.y<b.y+b.h){ b.alive=false; ball.vy=-ball.vy; score+=5; document.getElementById('breakout-score').textContent=score; } });
    }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); bricks.forEach(b=>{ if(b.alive){ ctx.fillStyle='#ffd166'; ctx.fillRect(b.x,b.y,b.w,b.h); ctx.strokeStyle='#b88600'; ctx.strokeRect(b.x,b.y,b.w,b.h); } }); ctx.fillStyle='#fff'; ctx.fillRect(paddle.x, canvas.clientHeight-40, paddle.w, paddle.h); ctx.beginPath(); ctx.fillStyle='#ff6b6b'; ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill(); }
    window.addEventListener('mousemove', e=>{ const rect=canvas.getBoundingClientRect(); paddle.x = Math.min(Math.max(0, e.clientX - rect.left - paddle.w/2), canvas.clientWidth - paddle.w); });
    document.getElementById('breakout-restart').addEventListener('click', ()=>{ score=0; document.getElementById('breakout-score').textContent=0; buildBricks(); ball.x=canvas.clientWidth/2; ball.y=canvas.clientHeight-60; ball.vy=-140; });
    document.getElementById('breakout-pause').addEventListener('click', ()=>{ paused=!paused; document.getElementById('breakout-pause').textContent=paused?'Retomar':'Pausar'; });
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('load', ()=>{ fit(); buildBricks(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>{ fit(); buildBricks(); });
  })();
  </script>

  <!-- SPACE INVADERS (simple) -->
  <script>
  (function(){
    const canvas = document.getElementById('invaders-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d'); fitCanvasToWrapper(canvas);
    let ship={x:0,y:0,w:28,h:12}, bullets=[], invaders=[], invVel=20, last=0, score=0, paused=false;
    function fit(){ fitCanvasToWrapper(canvas); ship.x = canvas.clientWidth/2 - ship.w/2; ship.y = canvas.clientHeight - 50; buildInvaders(); }
    function buildInvaders(){ invaders=[]; const cols=8, rows=3, gap=8, w=32, startX=20; for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) invaders.push({x:startX + c*(w+gap), y:40+r*(w*0.6), w:w, h:18, alive:true}); }
    function update(dt){ if(paused) return; invaders.forEach(i=>i.x += invVel*dt); const aliveInv = invaders.filter(i=>i.alive); if(!aliveInv.length) return; const rightMost=Math.max(...aliveInv.map(i=>i.x+i.w)); const leftMost=Math.min(...aliveInv.map(i=>i.x)); if(rightMost>canvas.clientWidth-10 || leftMost<10){ invVel *= -1; invaders.forEach(i=>i.y+=10); } bullets.forEach(b=>b.y-=b.v*dt); bullets = bullets.filter(b=>b.y>0 && !b.hit);
      bullets.forEach(b=>{ invaders.forEach(inv=>{ if(inv.alive && b.x>inv.x && b.x<inv.x+inv.w && b.y>inv.y && b.y<inv.y+inv.h){ inv.alive=false; b.hit=true; score+=10; document.getElementById('invaders-score').textContent=score; } }); });
    }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); ctx.fillStyle='#4ecdc4'; ctx.fillRect(ship.x,ship.y,ship.w,ship.h); invaders.forEach(inv=>{ if(inv.alive){ ctx.fillStyle='#ffd166'; ctx.fillRect(inv.x,inv.y,inv.w,inv.h); } }); ctx.fillStyle='#ff6b6b'; bullets.forEach(b=>ctx.fillRect(b.x-2,b.y-8,4,8)); }
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') ship.x -= 12; if(e.key==='ArrowRight') ship.x += 12; if(e.key===' ') bullets.push({x:ship.x+ship.w/2,y:ship.y, v:320}); if(e.key==='p'){ paused=!paused; document.getElementById('invaders-pause').textContent=paused?'Retomar':'Pausar'; } });
    document.getElementById('invaders-restart').addEventListener('click', ()=>{ score=0; document.getElementById('invaders-score').textContent=0; buildInvaders(); });
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('load', ()=>{ fit(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- ASTEROIDS -->
  <script>
  (function(){
    const canvas = document.getElementById('asteroids-canvas'); if(!canvas) return; const ctx = canvas.getContext('2d'); fitCanvasToWrapper(canvas);
    let ship={x:100,y:100,a:0,vx:0,vy:0}, asts=[], bullets=[], last=0, score=0;
    function fit(){ fitCanvasToWrapper(canvas); ship.x=canvas.clientWidth/2; ship.y=canvas.clientHeight/2; spawnAsteroids(3); }
    function spawnAsteroids(n){ asts=[]; for(let i=0;i<n;i++){ asts.push({x:Math.random()*canvas.clientWidth,y:Math.random()*canvas.clientHeight,vx:(Math.random()-0.5)*80,vy:(Math.random()-0.5)*80,r:20+Math.random()*30}); } }
    function update(dt){ ship.x+=ship.vx*dt; ship.y+=ship.vy*dt; ship.x=(ship.x+canvas.clientWidth)%canvas.clientWidth; ship.y=(ship.y+canvas.clientHeight)%canvas.clientHeight;
      asts.forEach(a=>{ a.x+=a.vx*dt; a.y+=a.vy*dt; a.x=(a.x+canvas.clientWidth)%canvas.clientWidth; a.y=(a.y+canvas.clientHeight)%canvas.clientHeight; });
      bullets.forEach(b=>{ b.x+=b.vx*dt; b.y+=b.vy*dt; });
      bullets.forEach(b=>{ asts.forEach(a=>{ if(Math.hypot(a.x-b.x,a.y-b.y) < a.r){ a.dead=true; b.dead=true; score+=5; document.getElementById('asteroids-score').textContent=score; } }); });
      asts = asts.filter(a=>!a.dead); bullets = bullets.filter(b=>!b.dead && b.x> -50 && b.x<canvas.clientWidth+50);
      if(Math.random()<0.005) spawnAsteroids(1);
    }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); ctx.save(); ctx.translate(ship.x,ship.y); ctx.rotate(ship.a); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(-8,6); ctx.lineTo(-6,0); ctx.lineTo(-8,-6); ctx.closePath(); ctx.fill(); ctx.restore();
      asts.forEach(a=>{ ctx.beginPath(); ctx.fillStyle='#bdb76b'; ctx.arc(a.x,a.y,a.r,0,Math.PI*2); ctx.fill(); });
      bullets.forEach(b=>{ ctx.fillStyle='#ff6b6b'; ctx.fillRect(b.x-2,b.y-2,4,4); }); }
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') ship.a -= 0.14; if(e.key==='ArrowRight') ship.a += 0.14; if(e.key==='ArrowUp'){ ship.vx += Math.cos(ship.a)*6; ship.vy += Math.sin(ship.a)*6; } if(e.key===' ') bullets.push({x:ship.x+Math.cos(ship.a)*12,y:ship.y+Math.sin(ship.a)*12,vx:Math.cos(ship.a)*250,vy:Math.sin(ship.a)*250}); });
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('load', ()=>{ fit(); spawnAsteroids(4); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- PAC-MAN (lite) -->
  <script>
  (function(){
    const canvas = document.getElementById('pacman-canvas'); if(!canvas) return; const ctx = canvas.getContext('2d'); fitCanvasToWrapper(canvas);
    let gridSize=16, cols=10, rows=10, pac={x:1,y:1}, pellets=[], ghosts=[], last=0, score=0;
    function fit(){ fitCanvasToWrapper(canvas); gridSize = Math.max(12, Math.floor(canvas.clientWidth/cols)); buildLevel(); }
    function buildLevel(){ pellets=[]; for(let y=0;y<rows;y++) for(let x=0;x<cols;x++) if(!(x===0||y===0||x===cols-1||y===rows-1)) pellets.push({x,y}); ghosts=[{x:cols-2,y:rows-2},{x:cols-2,y:1}]; }
    function update(dt){ ghosts.forEach(g=>{ if(Math.random()<0.02){ const dirs=[[-1,0],[1,0],[0,-1],[0,1]]; const d=dirs[Math.floor(Math.random()*dirs.length)]; g.x=clamp(g.x+d[0],1,cols-2); g.y=clamp(g.y+d[1],1,rows-2); } });
      for(let i=pellets.length-1;i>=0;i--){ if(pellets[i].x===pac.x && pellets[i].y===pac.y){ pellets.splice(i,1); score+=10; document.getElementById('pacman-score').textContent=score; } } }
    function draw(){ fitCanvasToWrapper(canvas); const cell = Math.floor(canvas.clientWidth/cols); ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      ctx.fillStyle='#ffd166'; pellets.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x*cell+cell/2,p.y*cell+cell/2,3,0,Math.PI*2); ctx.fill(); });
      ctx.fillStyle='#ffde59'; ctx.beginPath(); ctx.arc(pac.x*cell+cell/2,pac.y*cell+cell/2,cell*0.45,0,Math.PI*2); ctx.fill();
      ghosts.forEach(g=>{ ctx.fillStyle='#ff6b6b'; ctx.fillRect(g.x*cell+4,g.y*cell+4,cell-8,cell-8); });
    }
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') pac.x=clamp(pac.x-1,1,cols-2); if(e.key==='ArrowRight') pac.x=clamp(pac.x+1,1,cols-2); if(e.key==='ArrowUp') pac.y=clamp(pac.y-1,1,rows-2); if(e.key==='ArrowDown') pac.y=clamp(pac.y+1,1,rows-2); });
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('load', ()=>{ fit(); buildLevel(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- FROGGER (mini) -->
  <script>
  (function(){
    const canvas = document.getElementById('frogger-canvas'); if(!canvas) return; const ctx = canvas.getContext('2d'); fitCanvasToWrapper(canvas);
    let frog={x:0,y:0}, cars=[], last=0, level=1;
    function fit(){ fitCanvasToWrapper(canvas); frog.x = Math.floor(canvas.clientWidth/2); frog.y = canvas.clientHeight - 40; buildCars(); document.getElementById('frogger-level').textContent=level; }
    function buildCars(){ cars=[]; for(let r=0;r<4;r++){ for(let c=0;c<3;c++){ cars.push({x:Math.random()*canvas.clientWidth,y:60+r*40,w:60,h:24,spd:40 + r*20}); } } }
    function update(dt){ cars.forEach(c=>{ c.x += c.spd*dt; if(c.x>canvas.clientWidth+50) c.x=-100; if(Math.abs(c.x - frog.x) < 30 && Math.abs(c.y - frog.y) < 20){ frog.x = canvas.clientWidth/2; frog.y = canvas.clientHeight-40; level=1; document.getElementById('frogger-level').textContent=level; } if(frog.y < 40){ level++; document.getElementById('frogger-level').textContent=level; frog.x=canvas.clientWidth/2; frog.y=canvas.clientHeight-40; } }); }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); cars.forEach(c=>{ ctx.fillStyle='#ff8a5c'; ctx.fillRect(c.x,c.y,c.w,c.h); }); ctx.fillStyle='#2ecc71'; ctx.fillRect(frog.x-12,frog.y-12,24,24); }
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') frog.x -= 40; if(e.key==='ArrowRight') frog.x += 40; if(e.key==='ArrowUp') frog.y -= 40; if(e.key==='ArrowDown') frog.y += 40; });
    window.addEventListener('load', ()=>{ fit(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
  })();
  </script>

  <!-- BUBBLE SHOOTER (simple) -->
  <script>
  (function(){
    const canvas = document.getElementById('bubble-canvas'); if(!canvas) return; const ctx=canvas.getContext('2d'); fitCanvasToWrapper(canvas);
    let bubbles=[], shooter={x:0,angle:Math.PI/2}, last=0, score=0;
    function fit(){ fitCanvasToWrapper(canvas); shooter.x = canvas.clientWidth/2; buildGrid(); }
    function buildGrid(){ bubbles=[]; const cols=8, rows=6; for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) bubbles.push({x:20+c*36,y:20+r*36,r:14,color: ['#ffd166','#ff6b6b','#2ecc71','#9b5cff'][Math.floor(Math.random()*4)]}); }
    function shoot(angle){ bubbles.push({x:shooter.x,y:canvas.clientHeight-30,vx:Math.cos(angle)*320,vy:Math.sin(angle)*-320,r:10,color:'#ffde59',player:true}); }
    function update(dt){ const all=bubbles; for(let b of all){ if(b.player){ b.x+=b.vx*dt; b.y+=b.vy*dt; for(let g of bubbles){ if(!g.player && Math.hypot(b.x-g.x,b.y-g.y) < b.r+g.r){ b.dead=true; g.dead=true; score+=10; document.getElementById('bubble-score').textContent=score; } } } } bubbles=bubbles.filter(b=>!b.dead && b.y> -50 && b.x>-50 && b.x<canvas.clientWidth+50); }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); bubbles.forEach(b=>{ ctx.beginPath(); ctx.fillStyle=b.color; ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }); ctx.fillStyle='#fff'; ctx.fillRect(shooter.x-20, canvas.clientHeight-28, 40, 10); }
    canvas.addEventListener('click', e=>{ const rect=canvas.getBoundingClientRect(); const ax = e.clientX-rect.left; const ay = e.clientY-rect.top; const ang = Math.atan2(ay - (canvas.clientHeight-30), ax - shooter.x); shoot(ang); });
    window.addEventListener('load', ()=>{ fit(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    document.getElementById('bubble-restart').addEventListener('click', ()=>{ score=0; document.getElementById('bubble-score').textContent=0; buildGrid(); });
  })();
  </script>

  <!-- RUNNER (endless) -->
  <script>
  (function(){
    const canvas = document.getElementById('runner-canvas'); if(!canvas) return; const ctx = canvas.getContext('2d'); fitCanvasToWrapper(canvas);
    let player={x:50,y:0,vy:0,ground:0}, obstacles=[], speed=140, spawn=0, last=0, score=0;
    function fit(){ fitCanvasToWrapper(canvas); player.ground = canvas.clientHeight-40; player.y = player.ground; obstacles=[]; score=0; document.getElementById('runner-score').textContent=0; }
    function jump(){ if(player.y>=player.ground-1){ player.vy=-420; } }
    function update(dt){ player.vy += 1400*dt; player.y += player.vy*dt; if(player.y>player.ground) { player.y=player.ground; player.vy=0; } obstacles.forEach(o=>o.x -= speed*dt); spawn+=dt; if(spawn>1.2){ spawn=0; obstacles.push({x:canvas.clientWidth+20,y:player.ground-24,w:30,h:24}); } obstacles = obstacles.filter(o=>o.x+o.w> -20); obstacles.forEach(o=>{ if(Math.abs(o.x - player.x) < 24 && Math.abs(o.y - player.y) < 20){ obstacles=[]; score=0; document.getElementById('runner-score').textContent=0; } if(o.x + o.w < player.x && !o.passed){ o.passed=true; score++; document.getElementById('runner-score').textContent=score; } }); }
    function draw(){ ctx.fillStyle='#0b0b0b'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight); ctx.fillStyle='#fff'; ctx.fillRect(player.x-12,player.y-24,24,24); obstacles.forEach(o=>{ ctx.fillStyle='#ff8a5c'; ctx.fillRect(o.x,o.y,o.w,o.h); }); ctx.fillStyle='#6abf9f'; ctx.fillRect(0,canvas.clientHeight-40,canvas.clientWidth,40); }
    window.addEventListener('keydown', e=>{ if(e.key===' '||e.key==='ArrowUp') jump(); });
    document.getElementById('runner-restart').addEventListener('click', ()=>{ fit(); });
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    window.addEventListener('load', ()=>{ fit(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- ================= BATTLESHIP (player vs IA Hunt & Target) ================= -->
  <script>
  (function(){
    // Basic battleship single-player vs IA with simple "hunt & target" strategy.
    const PLAYER_CANVAS = document.getElementById('battleship-player');
    const AI_CANVAS = document.getElementById('battleship-ai');
    if(!PLAYER_CANVAS || !AI_CANVAS) return;
    fitCanvasToWrapper(PLAYER_CANVAS); fitCanvasToWrapper(AI_CANVAS);
    const PCTX = PLAYER_CANVAS.getContext('2d'), ACTX = AI_CANVAS.getContext('2d');

    const SIZE = 10; // 10x10 board
    let CELL_PX_PLAYER = Math.floor(PLAYER_CANVAS.clientWidth / SIZE);
    let CELL_PX_AI = Math.floor(AI_CANVAS.clientWidth / SIZE);

    let playerGrid = [], aiGrid = [];
    let playerShots = []; // {x,y,hit}
    let aiShots = [];
    const SHIPS = [5,4,3,3,2];

    // AI state for Hunt & Target
    let aiState = { mode: 'hunt', huntMoves: [], targetStack: [] };

    function makeEmptyGrid(){ return Array.from({length:SIZE},()=>Array(SIZE).fill(0)); }

    function placeShipsRandom(grid){
      for(let len of SHIPS){
        let placed=false, attempts=0;
        while(!placed && attempts<200){
          attempts++;
          const vert = Math.random()<0.5;
          const x = Math.floor(Math.random()*(vert?SIZE:SIZE-len+1));
          const y = Math.floor(Math.random()*(vert?SIZE-len+1:SIZE));
          let ok=true;
          for(let i=0;i<len;i++){
            const xx = x + (vert?0:i), yy = y + (vert?i:0);
            if(grid[yy][xx] !== 0) { ok=false; break; }
          }
          if(ok){
            for(let i=0;i<len;i++){ const xx = x + (vert?0:i), yy = y + (vert?i:0); grid[yy][xx] = 1; }
            placed=true;
          }
        }
      }
    }

    function initBoards(){
      playerGrid = makeEmptyGrid(); aiGrid = makeEmptyGrid();
      placeShipsRandom(playerGrid); placeShipsRandom(aiGrid);
      playerShots = []; aiShots = [];
      aiState = { mode:'hunt', huntMoves: generateHuntMoves(), targetStack: [] };
      redrawAll();
    }

    function generateHuntMoves(){
      // generate checkerboard hunt moves for efficiency
      const moves=[];
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if((r+c)%2===0) moves.push({x:c,y:r});
      // shuffle
      for(let i=moves.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [moves[i],moves[j]]=[moves[j],moves[i]]; }
      return moves;
    }

    function redrawAll(){
      fitCanvasToWrapper(PLAYER_CANVAS); fitCanvasToWrapper(AI_CANVAS);
      CELL_PX_PLAYER = Math.floor(PLAYER_CANVAS.clientWidth / SIZE);
      CELL_PX_AI = Math.floor(AI_CANVAS.clientWidth / SIZE);
      drawGrid(PCTX, playerGrid, CELL_PX_PLAYER, true, playerShots);
      drawGrid(ACTX, aiGrid, CELL_PX_AI, false, playerShots);
    }

    function drawGrid(ctx, grid, cell, showShips, shots){
      ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
      ctx.fillStyle = '#cfe9ff'; ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
      // cells
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          const x = c*cell, y = r*cell;
          ctx.strokeStyle = '#b3d4f7'; ctx.strokeRect(x+0.5, y+0.5, cell-1, cell-1);
          if(showShips && grid[r][c] === 1){
            ctx.fillStyle = '#779ecb'; ctx.fillRect(x+2,y+2,cell-4,cell-4);
          }
        }
      }
      // shots
      (shots||[]).forEach(s=>{
        if(s.owner === 'player'){ // show on AI canvas
          const sx = s.x*cell + cell/2, sy = s.y*cell + cell/2;
          ctx.beginPath(); ctx.fillStyle = s.hit ? '#e74c3c' : '#111'; ctx.arc(sx,sy,cell*0.18,0,Math.PI*2); ctx.fill();
        } else { // ai shots on player canvas
          const sx = s.x*cell + cell/2, sy = s.y*cell + cell/2;
          ctx.beginPath(); ctx.fillStyle = s.hit ? '#e74c3c' : '#111'; ctx.arc(sx,sy,cell*0.18,0,Math.PI*2); ctx.fill();
        }
      });
    }

    // Player clicks AI canvas to shoot
    AI_CANVAS.addEventListener('click', function(e){
      const rect = AI_CANVAS.getBoundingClientRect();
      const x = Math.floor((e.clientX-rect.left)/CELL_PX_AI);
      const y = Math.floor((e.clientY-rect.top)/CELL_PX_AI);
      if(x<0||x>=SIZE||y<0||y>=SIZE) return;
      // already shot?
      if(playerShots.some(s=>s.x===x&&s.y===y)) return;
      const hit = aiGrid[y][x] === 1;
      playerShots.push({x,y,hit,owner:'player'});
      if(hit){ aiGrid[y][x] = 2; } else aiGrid[y][x] = 3;
      redrawAll();
      checkVictory();
      // AI turn after 250ms
      setTimeout(aiTurn, 300);
    });

    function checkVictory(){
      const aiLeft = aiGrid.flat().filter(v=>v===1).length;
      const playerLeft = playerGrid.flat().filter(v=>v===1).length;
      if(aiLeft===0){ alert('ParabÃ©ns â€” venceste a IA!'); }
      if(playerLeft===0){ alert('A IA venceu. Tenta outra vez.'); }
    }

    // AI logic: hunt & target
    function aiTurn(){
      // choose move
      let move;
      if(aiState.targetStack.length){
        move = aiState.targetStack.pop();
      } else if(aiState.huntMoves.length){
        move = aiState.huntMoves.pop();
      } else {
        // fallback: any cell not tried yet
        const tried = new Set(aiShots.map(s=>`${s.x},${s.y}`));
        for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(!tried.has(`${x},${y}`)) { move={x,y}; break; }
      }
      if(!move) return;
      // record
      const x = move.x, y = move.y;
      const hit = playerGrid[y][x] === 1;
      aiShots.push({x,y,hit,owner:'ai'});
      if(hit){ playerGrid[y][x] = 2;
        // push adjacent cells to target stack (prioritize)
        const adj = [{x:x+1,y},{x:x-1,y},{x,y+1},{x,y-1}];
        adj.forEach(a=>{ if(a.x>=0&&a.x<SIZE&&a.y>=0&&a.y<SIZE && !aiShots.some(s=>s.x===a.x&&s.y===a.y)) aiState.targetStack.push(a); });
      } else {
        if(playerGrid[y][x] === 0) playerGrid[y][x] = 3;
      }
      redrawAll();
      checkVictory();
    }

    // Buttons
    document.getElementById('battleship-restart').addEventListener('click', ()=>initBoards());
    document.getElementById('battleship-auto').addEventListener('click', ()=>{
      // auto-place player's ships (random)
      playerGrid = makeEmptyGrid();
      placeShipsRandom(playerGrid);
      redrawAll();
    });

    // initial
    initBoards();
    window.addEventListener('resize', ()=>{ setTimeout(()=>{ initBoards(); }, 160); });
  })();
  </script>

  <!-- ================= VERTICAL SHOOTER (player ship vs waves) ================= -->
  <script>
  (function(){
    const canvas = document.getElementById('shooter-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d'); fitCanvasToWrapper(canvas);
    let last=0, player={x:0,y:0,w:28,h:24,vy:0,lives:3}, bullets=[], enemies=[], spawn=0, score=0, running=true, paused=false;
    function fit(){ fitCanvasToWrapper(canvas); player.x = canvas.clientWidth/2; player.y = canvas.clientHeight - 60; }
    function spawnEnemy(){ const w=canvas.clientWidth; enemies.push({x:20+Math.random()*(w-40), y:-20, vx:(Math.random()-0.5)*40, vy:40 + Math.random()*30, hp:1}); }
    function update(dt){
      if(paused || !running) return;
      // player movement (vy controlled by keys)
      player.x = clamp(player.x, 20, canvas.clientWidth-20);
      // bullets
      bullets.forEach(b=>{ b.y -= b.speed * dt; });
      bullets = bullets.filter(b=>b.y > -10 && !b.dead);
      // enemies
      enemies.forEach(e=>{ e.x += e.vx*dt; e.y += e.vy*dt; });
      enemies = enemies.filter(e=>!e.dead && e.y < canvas.clientHeight+50);
      // collisions bullets-enemies
      bullets.forEach(b=>{ enemies.forEach(e=>{ if(!e.dead && Math.hypot(e.x-b.x,e.y-b.y) < 20){ e.hp--; b.dead=true; if(e.hp<=0){ e.dead=true; score+=10; document.getElementById('shooter-score').textContent=score; } } }); });
      // spawn logic
      spawn += dt;
      if(spawn > 1.0){ spawn = 0; spawnEnemy(); }
      // enemy reaches player
      enemies.forEach(e=>{ if(Math.hypot(e.x-player.x,e.y-player.y) < 28){ e.dead=true; player.lives--; if(player.lives<=0){ running=false; } } });
    }
    function draw(){
      fitCanvasToWrapper(canvas);
      ctx.fillStyle='#041628'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      // player
      ctx.fillStyle = '#7bd389'; ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(player.x-14, player.y+18); ctx.lineTo(player.x+14, player.y+18); ctx.closePath(); ctx.fill();
      // bullets
      ctx.fillStyle='#ffde59'; bullets.forEach(b=>ctx.fillRect(b.x-2,b.y-6,4,8));
      // enemies
      enemies.forEach(e=>{ ctx.fillStyle='#ff6b6b'; ctx.beginPath(); ctx.arc(e.x,e.y,12,0,Math.PI*2); ctx.fill(); });
      // HUD
      ctx.fillStyle='#ffffff'; ctx.font='12px sans-serif'; ctx.fillText(`Lives: ${player.lives}`, 8, 16); ctx.fillText(`Score: ${score}`, 8, 32);
    }
    function loop(ts){ if(!last) last=ts; const dt=(ts-last)/1000; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    // controls
    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') player.x -= 18; if(e.key==='ArrowRight') player.x += 18; if(e.key===' ') { bullets.push({x:player.x,y:player.y-10,speed:420}); } if(e.key==='p'){ paused=!paused; document.getElementById('shooter-pause').textContent=paused?'Retomar':'Pausar'; } });
    document.getElementById('shooter-restart').addEventListener('click', ()=>{ score=0; player.lives=3; bullets=[]; enemies=[]; running=true; document.getElementById('shooter-score').textContent=0; });
    document.getElementById('shooter-pause').addEventListener('click', ()=>{ paused=!paused; document.getElementById('shooter-pause').textContent=paused?'Retomar':'Pausar'; });
    window.addEventListener('load', ()=>{ fit(); last=performance.now(); requestAnimationFrame(loop); }); window.addEventListener('resize', ()=>fit());
  })();
  </script>

  <!-- final helper: resume interactions on first gesture -->
  <script>
  (function(){ function resume(){ document.documentElement.classList.add('user-gesture'); window.removeEventListener('keydown',resume); window.removeEventListener('pointerdown',resume); window.removeEventListener('touchstart',resume); } window.addEventListener('keydown',resume,{once:true}); window.addEventListener('pointerdown',resume,{once:true}); window.addEventListener('touchstart',resume,{once:true}); })();
  </script>

</body>
</html>
