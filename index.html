<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Meus Jogos ‚Äî Tetris, Memory, Pong</title>
  <style>
    :root{
      --card-bg:#fff;
      --accent:#3f7bff;
      --page-pad:28px;
      --card-w:360px;
      --page-max:1200px;
    }
    body{
      margin:0;
      font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background:linear-gradient(120deg,#e9f0ff,#f8fafc);
      color:#17202a;
      padding:var(--page-pad);
    }
    h1{text-align:center;margin:0 0 18px}

    /* Layout */
    .games-row{
      display:flex;
      gap:20px;
      justify-content:center;
      align-items:stretch;
      flex-wrap:wrap;
      max-width:var(--page-max);
      margin:0 auto;
    }
    .game-card{
      flex:0 0 var(--card-w);
      width:var(--card-w);
      min-height:480px;
      display:flex;
      flex-direction:column;
      background:var(--card-bg);
      border-radius:12px;
      box-shadow:0 12px 36px rgba(16,24,40,0.06);
      overflow:hidden;
    }
    .game-card>h2{ margin:12px 8px; font-size:1.05rem; text-align:center; flex:0 0 auto; }
    .game-card__body{
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:12px;
      box-sizing:border-box;
    }

    .game-inner{
      flex:1 1 auto;
      width:100%;
      max-height:360px;
      min-height:180px;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:6px;
      box-sizing:border-box;
    }
    .game-inner canvas,
    .game-inner img,
    .game-inner .board{
      max-width:100%;
      max-height:100%;
      width:auto !important;
      height:auto !important;
      display:block;
      object-fit:contain;
    }

    .controls{ display:flex; gap:8px; justify-content:center; margin-top:12px; }
    .btn{ background:var(--accent); color:#fff; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
    .btn:disabled{ opacity:.6; cursor:default; }

    /* Memory cells */
    .cell{
      border-radius:8px;
      background:#56606a;
      color:transparent;
      border:0;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:transform .18s, background .18s, color .18s;
      box-shadow: 0 6px 14px rgba(10,20,40,0.05);
    }
    .cell.open{ background:#fff; color:#111; transform:scale(1.04) }
    .cell.matched{ background:#dff7e7; color:#0b5132; cursor:default }

    /* Memory board: ensure grid layout and centering */
    #mem-board {
      display: grid;
      gap: 8px;
      justify-items: center;
      align-items: center;
      width: 100%;
      justify-content: center;
    }

    @media (max-width:880px){
      .games-row{ gap:14px }
      .game-card{ flex:1 1 92%; width:auto; min-height:auto }
      .game-inner{ max-height:420px }
    }
  </style>
</head>
<body>
  <h1>Meus Jogos</h1>

  <div class="games-row">

    <!-- TETRIS -->
    <div class="game-card" id="tetris-card">
      <h2>Tetris (responsivo)</h2>
      <div class="game-card__body">
        <div style="display:flex;gap:12px;justify-content:center;font-weight:700">
          <div>Pontos: <span id="tetris-score">0</span></div>
          <div>N√≠vel: <span id="tetris-level">1</span></div>
        </div>

        <div class="game-inner">
          <canvas id="tetris-canvas" data-cols="10" data-rows="20"
                  style="width:100%; height:100%; display:block; border-radius:10px; background:#111;"></canvas>
        </div>

        <div class="controls" style="margin-top:auto">
          <button id="tetris-restart" class="btn">Reiniciar</button>
          <button id="tetris-pause" class="btn">Pausar</button>
        </div>
      </div>
    </div>

    <!-- MEMORY -->
    <div class="game-card" id="mem-card">
      <h2>Memory ‚Äî N√≠veis Din√¢micos</h2>
      <div class="game-card__body">
        <div style="display:flex;gap:12px;justify-content:center;font-weight:700">
          <div>N√≠vel: <span id="mem-lvl">1</span></div>
          <div>Movimentos: <span id="mem-moves">0</span></div>
          <div>Pontua√ß√£o: <span id="mem-score">0</span></div>
        </div>

        <div class="game-inner">
          <div id="mem-board" aria-live="polite" style="margin-top:10px"></div>
        </div>

        <div class="controls" style="margin-top:auto">
          <button id="mem-restart" class="btn">Reiniciar</button>
          <button id="mem-next" class="btn" disabled>Pr√≥ximo N√≠vel</button>
        </div>
      </div>
    </div>

    <!-- PONG -->
    <div class="game-card" id="pong-card">
      <h2>Pong</h2>
      <div class="game-card__body">
        <div style="display:flex;gap:12px;justify-content:center;font-weight:700">
          <div>Jogador A: <span id="pong-score-a">0</span></div>
          <div>Jogador B: <span id="pong-score-b">0</span></div>
        </div>

        <div class="game-inner" style="margin-top:10px;">
          <canvas id="pong-canvas" style="width:100%; height:100%; display:block; border-radius:10px; background:#0b0b0b;"></canvas>
        </div>

        <div class="controls" style="margin-top:auto">
          <button id="pong-restart" class="btn">Reiniciar</button>
          <button id="pong-pause" class="btn">Pausar</button>
        </div>
      </div>
    </div>

  </div>

  <!-- ================= TETRIS: implementation ================= -->
  <script>
  (function(){
    const canvas = document.getElementById('tetris-canvas');
    const scoreEl = document.getElementById('tetris-score');
    const levelEl = document.getElementById('tetris-level');
    const btnRestart = document.getElementById('tetris-restart');
    const btnPause = document.getElementById('tetris-pause');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');

    const COLS = parseInt(canvas.dataset.cols,10) || 10;
    const ROWS = parseInt(canvas.dataset.rows,10) || 20;

    const SHAPES = {
      I: [[1,1,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]],
      O: [[1,1],[1,1]],
      S: [[0,1,1],[1,1,0]],
      T: [[0,1,0],[1,1,1]],
      Z: [[1,1,0],[0,1,1]]
    };
    const COLORS = { I:'#00d2ff', J:'#ff6b6b', L:'#ffd166', O:'#ffd86b', S:'#2ecc71', T:'#9b5cff', Z:'#ff6bc6' };

    function rotate(matrix){
      const m = matrix.length, n = matrix[0].length;
      const out = Array.from({length:n},()=>Array(m).fill(0));
      for(let r=0;r<m;r++) for(let c=0;c<n;c++) out[c][m-1-r]=matrix[r][c];
      return out;
    }
    function generateRotations(shape){
      const rotations = [];
      let current = shape.map(row=>row.slice());
      for(let i=0;i<4;i++){
        if(!rotations.some(r => JSON.stringify(r)===JSON.stringify(current))) rotations.push(current);
        current = rotate(current);
      }
      return rotations;
    }

    const PIECES = Object.keys(SHAPES).reduce((acc,k)=>{
      acc[k]=generateRotations(SHAPES[k]);
      return acc;
    },{});

    let board = [];
    let curr = null;
    let nextQueue = [];
    let score = 0;
    let level = 1;
    let linesCleared = 0;
    let dropAccumulator = 0;
    let lastTime = 0;
    let gameOver = false;
    let paused = false;

    function fitCanvasToContainer(){
      const dpr = window.devicePixelRatio || 1;
      const wrapper = canvas.closest('.game-inner') || canvas.parentElement || document.body;
      const rect = wrapper.getBoundingClientRect();
      const displayW = Math.max(40, Math.floor(rect.width));
      const displayH = Math.max(40, Math.floor(rect.height));
      canvas.style.width = displayW + 'px';
      canvas.style.height = displayH + 'px';
      const resW = Math.floor(displayW * dpr);
      const resH = Math.floor(displayH * dpr);
      if (canvas.width !== resW || canvas.height !== resH) {
        canvas.width = resW; canvas.height = resH;
        ctx.setTransform(dpr,0,0,dpr,0,0);
        return true;
      }
      return false;
    }
    function computeCellSize(){
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      const cellW = Math.floor(cssW / COLS), cellH = Math.floor(cssH / ROWS);
      return Math.max(6, Math.min(cellW, cellH));
    }
    function computeOffsets(cell){
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      const gridW = cell * COLS, gridH = cell * ROWS;
      return { offsetX: Math.floor((cssW - gridW)/2), offsetY: Math.floor((cssH - gridH)/2) };
    }

    function createBoard(){
      board = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
    }
    function spawnPiece(){
      if(nextQueue.length < 3) fillBag();
      const type = nextQueue.shift();
      const rotations = PIECES[type];
      const rotIndex = 0;
      const matrix = rotations[rotIndex];
      const x = Math.floor((COLS - matrix[0].length)/2);
      const y = -matrix.length;
      curr = {type, rotIndex, x, y};
      if(collision(curr,0,0,rotIndex)) gameOver = true;
    }
    function fillBag(){
      const bag = Object.keys(PIECES).slice();
      for(let i=bag.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]];
      }
      nextQueue.push(...bag);
    }
    function collision(piece,dx,dy,rotIdx){
      const rotations = PIECES[piece.type];
      const mat = rotations[rotIdx];
      for(let r=0;r<mat.length;r++){
        for(let c=0;c<mat[r].length;c++){
          if(!mat[r][c]) continue;
          const nx = piece.x + c + dx;
          const ny = piece.y + r + dy;
          if(nx < 0 || nx >= COLS) return true;
          if(ny >= ROWS) return true;
          if(ny >= 0 && board[ny][nx]) return true;
        }
      }
      return false;
    }
    function lockPiece(){
      const rotations = PIECES[curr.type];
      const mat = rotations[curr.rotIndex];
      for(let r=0;r<mat.length;r++){
        for(let c=0;c<mat[r].length;c++){
          if(!mat[r][c]) continue;
          const nx = curr.x + c;
          const ny = curr.y + r;
          if(ny >= 0 && ny < ROWS && nx >=0 && nx < COLS) board[ny][nx] = curr.type;
        }
      }
      clearLines();
      spawnPiece();
    }
    function clearLines(){
      let removed = 0;
      for(let r=ROWS-1;r>=0;r--){
        if(board[r].every(cell => cell !== 0)){
          board.splice(r,1);
          board.unshift(Array(COLS).fill(0));
          removed++;
          r++;
        }
      }
      if(removed>0){
        linesCleared += removed;
        score += [0,40,100,300,1200][removed] * level;
        const newLevel = Math.floor(linesCleared / 10) + 1;
        if(newLevel !== level) level = newLevel;
        scoreEl.textContent = score;
        levelEl.textContent = level;
      }
    }

    function move(dx){
      if(!curr || gameOver || paused) return;
      if(!collision(curr,dx,0,curr.rotIndex)) curr.x += dx;
    }
    function rotateCurr(){
      if(!curr || gameOver || paused) return;
      const rotations = PIECES[curr.type];
      const nextRot = (curr.rotIndex + 1) % rotations.length;
      const kicks = [0,-1,1,-2,2];
      for(let k of kicks){
        if(!collision(curr,k,0,nextRot)){
          curr.x += k;
          curr.rotIndex = nextRot;
          return;
        }
      }
    }
    function softDrop(){
      if(!curr || gameOver || paused) return false;
      if(!collision(curr,0,1,curr.rotIndex)){
        curr.y += 1;
        return true;
      } else {
        if(curr.y < 0) gameOver = true;
        else lockPiece();
        return false;
      }
    }
    function hardDrop(){
      if(!curr || gameOver || paused) return;
      while(!collision(curr,0,1,curr.rotIndex)){ curr.y++; score += 2; }
      lockPiece();
      scoreEl.textContent = score;
    }

    window.addEventListener('keydown', (e)=>{
      if(e.key === 'ArrowLeft'){ e.preventDefault(); move(-1); }
      else if(e.key === 'ArrowRight'){ e.preventDefault(); move(1); }
      else if(e.key === 'ArrowUp'){ e.preventDefault(); rotateCurr(); }
      else if(e.key === 'ArrowDown'){ e.preventDefault(); softDrop(); score += 1; scoreEl.textContent = score; }
      else if(e.key === ' '){ e.preventDefault(); hardDrop(); }
      else if(e.key === 'p' || e.key === 'P'){ togglePause(); }
    });

    btnRestart && btnRestart.addEventListener('click', ()=>{ init(true); });
    btnPause && btnPause.addEventListener('click', ()=>{ togglePause(); });

    function togglePause(){
      paused = !paused;
      btnPause.textContent = paused ? 'Retomar' : 'Pausar';
    }

    function draw(){
      fitCanvasToContainer();
      const cell = computeCellSize();
      const {offsetX, offsetY} = computeOffsets(cell);
      ctx.fillStyle = '#0b0b0b';
      ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);

      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const x = offsetX + c * cell;
          const y = offsetY + r * cell;
          ctx.fillStyle = '#101115';
          ctx.fillRect(x, y, cell, cell);
          if(board[r][c]){
            const col = COLORS[board[r][c]] || '#999';
            ctx.fillStyle = col;
            ctx.fillRect(x+1, y+1, cell-2, cell-2);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.strokeRect(x+1, y+1, cell-2, cell-2);
          } else {
            ctx.fillStyle = 'rgba(255,255,255,0.02)';
            ctx.fillRect(x+1, y+1, cell-2, cell-2);
          }
        }
      }

      if(curr){
        const rotations = PIECES[curr.type];
        const mat = rotations[curr.rotIndex];
        const color = COLORS[curr.type] || '#fff';
        for(let r=0;r<mat.length;r++){
          for(let c=0;c<mat[r].length;c++){
            if(!mat[r][c]) continue;
            const x = offsetX + (curr.x + c) * cell;
            const y = offsetY + (curr.y + r) * cell;
            if(y + cell < offsetY) continue;
            ctx.fillStyle = color;
            ctx.fillRect(x+1, y+1, cell-2, cell-2);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.strokeRect(x+1, y+1, cell-2, cell-2);
          }
        }
      }

      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.strokeRect(offsetX+0.5, offsetY+0.5, cell*COLS-1, cell*ROWS-1);
    }

    function dropIntervalForLevel(l){ return Math.max(150, 800 - (l-1)*70); }

    function loop(time){
      if(!lastTime) lastTime = time;
      const dt = time - lastTime;
      lastTime = time;
      if(!paused && !gameOver){
        dropAccumulator += dt;
        const interval = dropIntervalForLevel(level);
        while(dropAccumulator >= interval){
          softDrop();
          dropAccumulator -= interval;
        }
      }
      draw();
      requestAnimationFrame(loop);
    }

    function init(forceReset){
      createBoard();
      nextQueue = [];
      fillBag();
      spawnPiece();
      score = 0; level = 1; linesCleared = 0;
      gameOver = false; paused = false; dropAccumulator = 0; lastTime = 0;
      scoreEl.textContent = score;
      levelEl.textContent = level;
    }

    fitCanvasToContainer();
    init(true);
    requestAnimationFrame(loop);

    window.tetrisCanvasHelper = { fitCanvasToContainer, computeCellSize, computeOffsets, canvas, ctx, COLS, ROWS };

    let resizeTimer;
    window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer = setTimeout(()=>{ fitCanvasToContainer(); }, 100); });
  })();
  </script>

  <!-- ================= MEMORY (grid & centered) ================= -->
  <script>
  (function(){
    const SYMBOLS = ['üçé','üçã','üçá','üçì','üçâ','üçí','üçä','ü•ù','üçç','ü•ë','üçë','üçå','üçê','üçà','ü••','üçè','üåΩ','ü•ï','ü•î','üå∂Ô∏è'];
    const BASE = [{r:2,c:2},{r:2,c:3},{r:3,c:4},{r:4,c:4},{r:4,c:5}];
    const MAX_SIZE = 8;
    function getLevelSpec(i){
      if(i < BASE.length) return normalize(BASE[i]);
      const extra = i - BASE.length;
      const incRows = Math.floor(extra/2);
      const incCols = extra % 2;
      let r = 4 + incRows, c = 5 + incCols + Math.floor(extra/4);
      r = Math.min(r, MAX_SIZE); c = Math.min(c, MAX_SIZE);
      return normalize({r,c});
    }
    function normalize(spec){
      let {r,c} = spec;
      if((r*c)%2!==0){ if(c<MAX_SIZE) c++; else if(r<MAX_SIZE) r++; else c++; }
      return {r,c};
    }

    let level = 0, rows=4, cols=4, board=[], first=null, second=null, lock=false, moves=0, score=0, matches=0;
    const boardEl = document.getElementById('mem-board');
    const movesEl = document.getElementById('mem-moves');
    const scoreEl = document.getElementById('mem-score');
    const lvlEl = document.getElementById('mem-lvl');
    const restartBtn = document.getElementById('mem-restart');
    const nextBtn = document.getElementById('mem-next');

    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
    function getCellSize(){ if(window.innerWidth < 420) return 48; if(window.innerWidth < 520) return 56; return 64; }

    function build(){
      const spec = getLevelSpec(level);
      rows = spec.r; cols = spec.c;
      const pairs = (rows*cols)/2;
      const pool = SYMBOLS.slice(0);
      shuffle(pool);
      const chosen = pool.slice(0,pairs);
      const symbols = shuffle([...chosen, ...chosen]);
      board = symbols.map((s,i)=>({id:i,symbol:s,matched:false}));

      const cellSize = getCellSize();
      boardEl.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
      boardEl.style.width = '100%';
      boardEl.style.justifyContent = 'center';
      boardEl.style.margin = '0 auto';
      boardEl.style.gap = '8px';

      boardEl.innerHTML = '';
      board.forEach(card=>{
        const btn = document.createElement('button');
        btn.className = 'cell';
        btn.dataset.id = card.id;
        btn.style.width = cellSize + 'px';
        btn.style.height = cellSize + 'px';
        btn.style.fontSize = Math.max(16, Math.round(cellSize * 0.45)) + 'px';
        btn.innerHTML = '<span aria-hidden="true"></span>';
        btn.addEventListener('click', onClick);
        boardEl.appendChild(btn);
      });

      first = second = null; lock = false; moves = 0; score = 0; matches = 0;
      movesEl && (movesEl.textContent = moves); scoreEl && (scoreEl.textContent = score); lvlEl && (lvlEl.textContent = level + 1);
      nextBtn && (nextBtn.disabled = true);
    }

    function openCard(el,card){ el.classList.add('open'); el.querySelector('span').textContent = card.symbol; }
    function closeCard(el){ el.classList.remove('open'); el.querySelector('span').textContent = ''; }
    function onClick(e){
      if(lock) return;
      const el = e.currentTarget;
      const id = +el.dataset.id;
      const card = board[id];
      if(card.matched) return;
      if(first && first.id === id) return;
      openCard(el,card);
      if(!first){ first = {id,el,card}; return; }
      second = {id,el,card};
      moves++; movesEl && (movesEl.textContent = moves); lock = true;
      if(first.card.symbol === second.card.symbol){
        setTimeout(()=>{
          first.card.matched = second.card.matched = true;
          first.el.classList.add('matched');
          second.el.classList.add('matched');
          matches++; score += 10; scoreEl && (scoreEl.textContent = score);
          first = second = null; lock = false; checkWin();
        }, 350);
      } else {
        setTimeout(()=>{
          closeCard(first.el); closeCard(second.el);
          score = Math.max(0, score - 1); scoreEl && (scoreEl.textContent = score);
          first = second = null; lock = false;
        }, 700);
      }
    }
    function checkWin(){
      const totalPairs = (rows*cols)/2;
      if(matches === totalPairs){
        nextBtn && (nextBtn.disabled = (level >= 999));
        if(nextBtn && !nextBtn.disabled) nextBtn.focus();
      }
    }
    restartBtn && restartBtn.addEventListener('click', build);
    nextBtn && nextBtn.addEventListener('click', ()=>{ level++; build(); });
    let resizeTimer;
    window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer = setTimeout(build, 180); });
    build();
  })();
  </script>

  <!-- ================= PONG (added) ================= -->
  <script>
  (function(){
    const canvas = document.getElementById('pong-canvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const scoreAEl = document.getElementById('pong-score-a');
    const scoreBEl = document.getElementById('pong-score-b');
    const btnRestart = document.getElementById('pong-restart');
    const btnPause = document.getElementById('pong-pause');

    function fitCanvas(){
      const dpr = window.devicePixelRatio || 1;
      const wrap = canvas.closest('.game-inner') || canvas.parentElement || document.body;
      const rect = wrap.getBoundingClientRect();
      const w = Math.max(50, Math.floor(rect.width));
      const h = Math.max(50, Math.floor(rect.height));
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      const rw = Math.floor(w * dpr), rh = Math.floor(h * dpr);
      if(canvas.width !== rw || canvas.height !== rh){
        canvas.width = rw; canvas.height = rh;
        ctx.setTransform(dpr,0,0,dpr,0,0);
        return true;
      }
      return false;
    }

    let paddleW = 8, paddleH = 80;
    let ballSize = 10;
    let speed = 280;
    let left = { x:0, y:0, vy:0, score:0 };
    let right = { x:0, y:0, vy:0, score:0 };
    let ball = { x:0, y:0, vx:0, vy:0 };
    let lastTime = 0;
    let paused = false;

    function resizeMetrics(){
      fitCanvas();
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;
      paddleH = Math.max(40, Math.floor(cssH * 0.18));
      paddleW = Math.max(6, Math.floor(cssW * 0.02));
      ballSize = Math.max(6, Math.floor(Math.min(cssW, cssH) * 0.03));
      left.x = 12;
      right.x = cssW - 12 - paddleW;
      left.y = Math.floor((cssH - paddleH)/2);
      right.y = Math.floor((cssH - paddleH)/2);
      spawnBall();
    }

    function spawnBall(direction){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ball.x = Math.floor(w / 2);
      ball.y = Math.floor(h / 2);
      const angle = (Math.random() * 0.6 - 0.3);
      const dir = (direction === 'left') ? -1 : (direction === 'right') ? 1 : (Math.random()<0.5? -1:1);
      const mag = speed + Math.random()*60;
      ball.vx = dir * mag * Math.cos(angle);
      ball.vy = mag * Math.sin(angle);
    }

    function resetScores(){
      left.score = 0; right.score = 0;
      updateScoreUI();
    }
    function updateScoreUI(){
      scoreAEl.textContent = left.score;
      scoreBEl.textContent = right.score;
    }

    function step(dt){
      if(paused) return;
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      left.y += left.vy * dt;
      right.y += right.vy * dt;
      left.y = Math.max(0, Math.min(cssH - paddleH, left.y));
      right.y = Math.max(0, Math.min(cssH - paddleH, right.y));
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;
      if(ball.y - ballSize/2 <= 0){ ball.y = ballSize/2; ball.vy = -ball.vy; }
      if(ball.y + ballSize/2 >= cssH){ ball.y = cssH - ballSize/2; ball.vy = -ball.vy; }
      if(ball.x - ballSize/2 <= left.x + paddleW){
        if(ball.y >= left.y && ball.y <= left.y + paddleH){
          ball.x = left.x + paddleW + ballSize/2;
          const rel = (ball.y - (left.y + paddleH/2)) / (paddleH/2);
          const speedMul = 1.06;
          const angle = rel * 0.9;
          const mag = Math.hypot(ball.vx, ball.vy) * speedMul;
          ball.vx = Math.abs(mag * Math.cos(angle));
          ball.vy = mag * Math.sin(angle);
        }
      }
      if(ball.x + ballSize/2 >= right.x){
        if(ball.y >= right.y && ball.y <= right.y + paddleH){
          ball.x = right.x - ballSize/2;
          const rel = (ball.y - (right.y + paddleH/2)) / (paddleH/2);
          const speedMul = 1.06;
          const angle = rel * 0.9;
          const mag = Math.hypot(ball.vx, ball.vy) * speedMul;
          ball.vx = -Math.abs(mag * Math.cos(angle));
          ball.vy = mag * Math.sin(angle);
        }
      }
      if(ball.x < -50){
        right.score++; updateScoreUI(); spawnBall('right');
      } else if(ball.x > cssW + 50){
        left.score++; updateScoreUI(); spawnBall('left');
      }
    }

    function draw(){
      ctx.fillStyle = '#0b0b0b';
      ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      const dashH = 12;
      for(let y = 0; y < canvas.clientHeight; y += dashH*2){
        ctx.fillRect(Math.floor(canvas.clientWidth/2)-1, y + 6, 2, dashH);
      }
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(left.x, left.y, paddleW, paddleH);
      ctx.fillRect(right.x, right.y, paddleW, paddleH);
      ctx.beginPath();
      ctx.fillStyle = '#ff7b7b';
      ctx.arc(ball.x, ball.y, ballSize/2, 0, Math.PI*2);
      ctx.fill();
    }

    function loop(ts){
      if(!lastTime) lastTime = ts;
      const dt = (ts - lastTime)/1000;
      lastTime = ts;
      step(dt);
      draw();
      requestAnimationFrame(loop);
    }

    window.addEventListener('keydown', e => {
      if(e.key === 'w' || e.key === 'W') left.vy = -speed;
      if(e.key === 's' || e.key === 'S') left.vy = speed;
      if(e.key === 'ArrowUp') right.vy = -speed;
      if(e.key === 'ArrowDown') right.vy = speed;
      if(e.key === 'p' || e.key === 'P') { paused = !paused; btnPause.textContent = paused ? 'Retomar' : 'Pausar'; }
    });
    window.addEventListener('keyup', e => {
      if(e.key === 'w' || e.key === 'W') left.vy = 0;
      if(e.key === 's' || e.key === 'S') left.vy = 0;
      if(e.key === 'ArrowUp') right.vy = 0;
      if(e.key === 'ArrowDown') right.vy = 0;
    });

    btnRestart && btnRestart.addEventListener('click', ()=>{
      resetScores(); spawnBall(); paused = false; btnPause && (btnPause.textContent = 'Pausar');
    });
    btnPause && btnPause.addEventListener('click', ()=>{ paused = !paused; btnPause.textContent = paused ? 'Retomar' : 'Pausar'; });

    function init(){
      resetScores();
      resizeMetrics();
      spawnBall();
      lastTime = 0;
      requestAnimationFrame(loop);
    }

    let resizeTimer;
    window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer = setTimeout(()=>{ resizeMetrics(); }, 120); });

    window.addEventListener('load', ()=>{ resizeMetrics(); setTimeout(()=>{ init(); }, 80); });
    setTimeout(()=>{ if(!canvas.width) resizeMetrics(); }, 200);
  })();
  </script>

</body>
</html>
<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Meus Jogos ‚Äî Tetris, Memory, Pong, Simon, Flappy</title>
  <style>
    :root{
      --card-bg:#fff;
      --accent:#3f7bff;
      --page-pad:20px;
      --card-w:360px;
      --page-max:1280px;
    }
    body{
      margin:0;
      font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background:linear-gradient(120deg,#e9f0ff,#f8fafc);
      color:#17202a;
      padding:var(--page-pad);
    }
    h1{text-align:center;margin:0 0 18px}

    .games-row{
      display:flex;
      gap:20px;
      justify-content:center;
      align-items:stretch;
      flex-wrap:wrap;
      max-width:var(--page-max);
      margin:0 auto;
    }
    .game-card{
      flex:0 0 var(--card-w);
      width:var(--card-w);
      min-height:480px;
      display:flex;
      flex-direction:column;
      background:var(--card-bg);
      border-radius:12px;
      box-shadow:0 12px 36px rgba(16,24,40,0.06);
      overflow:hidden;
    }
    .game-card>h2{ margin:12px 8px; font-size:1.05rem; text-align:center; flex:0 0 auto; }
    .game-card__body{
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:12px;
      box-sizing:border-box;
    }

    .game-inner{
      flex:1 1 auto;
      width:100%;
      max-height:360px;
      min-height:180px;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:6px;
      box-sizing:border-box;
    }
    .game-inner canvas,
    .game-inner img,
    .game-inner .board{
      max-width:100%;
      max-height:100%;
      width:auto !important;
      height:auto !important;
      display:block;
      object-fit:contain;
    }

    .controls{ display:flex; gap:8px; justify-content:center; margin-top:12px; }
    .btn{ background:var(--accent); color:#fff; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
    .btn:disabled{ opacity:.6; cursor:default; }

    /* Memory */
    .cell{
      border-radius:8px;
      background:#56606a;
      color:transparent;
      border:0;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:transform .18s, background .18s, color .18s;
      box-shadow: 0 6px 14px rgba(10,20,40,0.05);
    }
    .cell.open{ background:#fff; color:#111; transform:scale(1.04) }
    .cell.matched{ background:#dff7e7; color:#0b5132; cursor:default }
    #mem-board { display:grid; gap:8px; justify-items:center; align-items:center; width:100%; justify-content:center; }

    /* Simon */
    .simon-grid{
      width:100%;
      height:100%;
      display:grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap:12px;
      align-items:center;
      justify-items:center;
      padding:8px;
      box-sizing:border-box;
    }
    .simon-pad{
      width:90%;
      height:90%;
      border-radius:12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.12);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:800;
      color:#111;
      user-select:none;
      -webkit-user-select:none;
      touch-action:manipulation;
      transition: transform .12s, filter .12s;
    }
    .simon-pad:active{ transform:scale(.98) }
    .simon-pad.dim{ filter:brightness(.6) }
    .simon-controls { display:flex; gap:8px; justify-content:center; margin-top:8px; }

    /* Flappy small controls */
    .flappy-info { display:flex; gap:12px; justify-content:center; font-weight:700; }

    @media (max-width:880px){
      .games-row{ gap:14px }
      .game-card{ flex:1 1 92%; width:auto; min-height:auto }
      .game-inner{ max-height:420px }
    }
  </style>
</head>
<body>
  <h1>Meus Jogos</h1>

  <div class="games-row">

    <!-- TETRIS (kept) -->
    <div class="game-card" id="tetris-card">
      <h2>Tetris</h2>
      <div class="game-card__body">
        <div style="display:flex;gap:12px;justify-content:center;font-weight:700">
          <div>Pontos: <span id="tetris-score">0</span></div>
          <div>N√≠vel: <span id="tetris-level">1</span></div>
        </div>
        <div class="game-inner"><canvas id="tetris-canvas" data-cols="10" data-rows="20" style="width:100%;height:100%;display:block;border-radius:10px;background:#111;"></canvas></div>
        <div class="controls" style="margin-top:auto"><button id="tetris-restart" class="btn">Reiniciar</button><button id="tetris-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <!-- MEMORY (kept) -->
    <div class="game-card" id="mem-card">
      <h2>Memory</h2>
      <div class="game-card__body">
        <div style="display:flex;gap:12px;justify-content:center;font-weight:700">
          <div>N√≠vel: <span id="mem-lvl">1</span></div>
          <div>Movimentos: <span id="mem-moves">0</span></div>
          <div>Pontua√ß√£o: <span id="mem-score">0</span></div>
        </div>
        <div class="game-inner"><div id="mem-board" aria-live="polite" style="margin-top:10px"></div></div>
        <div class="controls" style="margin-top:auto"><button id="mem-restart" class="btn">Reiniciar</button><button id="mem-next" class="btn" disabled>Pr√≥ximo N√≠vel</button></div>
      </div>
    </div>

    <!-- SIMON (improved) -->
    <div class="game-card" id="simon-card">
      <h2>Simon (melhorado)</h2>
      <div class="game-card__body">
        <div style="display:flex;gap:12px;justify-content:center;font-weight:700">
          <div>N√≠vel: <span id="simon-level">0</span></div>
          <div>Recorde: <span id="simon-best">0</span></div>
        </div>

        <div class="game-inner">
          <div id="simon-root" style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;">
            <div class="simon-grid" id="simon-grid">
              <div class="simon-pad" id="pad-0" data-color="#2ecc71" style="background:#2ecc71;border:6px solid rgba(0,0,0,0.06)"></div>
              <div class="simon-pad" id="pad-1" data-color="#ffd166" style="background:#ffd166;border:6px solid rgba(0,0,0,0.06)"></div>
              <div class="simon-pad" id="pad-2" data-color="#ff6b6b" style="background:#ff6b6b;border:6px solid rgba(0,0,0,0.06)"></div>
              <div class="simon-pad" id="pad-3" data-color="#9b5cff" style="background:#9b5cff;border:6px solid rgba(0,0,0,0.06)"></div>
            </div>
          </div>
        </div>

        <div class="simon-controls">
          <button id="simon-start" class="btn">Start</button>
          <button id="simon-strict" class="btn">Strict</button>
          <button id="simon-restart" class="btn">Reiniciar</button>
        </div>
      </div>
    </div>

    <!-- FLAPPY (improved) -->
    <div class="game-card" id="flappy-card">
      <h2>Flappy (melhorado)</h2>
      <div class="game-card__body">
        <div class="flappy-info"><div>Pontos: <span id="flappy-score">0</span></div><div>Recorde: <span id="flappy-best">0</span></div></div>
        <div class="game-inner"><canvas id="flappy-canvas" style="width:100%;height:100%;display:block;border-radius:10px;background:#70c5ce;"></canvas></div>
        <div class="controls" style="margin-top:auto"><button id="flappy-restart" class="btn">Reiniciar</button><button id="flappy-pause" class="btn">Pausar</button></div>
      </div>
    </div>

    <!-- PONG kept minimal -->
    <div class="game-card" id="pong-card">
      <h2>Pong</h2>
      <div class="game-card__body">
        <div style="display:flex;gap:12px;justify-content:center;font-weight:700">
          <div>Jogador A: <span id="pong-score-a">0</span></div>
          <div>Jogador B: <span id="pong-score-b">0</span></div>
        </div>
        <div class="game-inner"><canvas id="pong-canvas" style="width:100%;height:100%;display:block;border-radius:10px;background:#0b0b0b;"></canvas></div>
        <div class="controls" style="margin-top:auto"><button id="pong-restart" class="btn">Reiniciar</button><button id="pong-pause" class="btn">Pausar</button></div>
      </div>
    </div>

  </div>

  <!-- ================= SCRIPTS ================= -->
  <!-- NOTE: Tetris / Memory / Pong kept as before (not included here for brevity) -->
  <!-- We'll include Simon and Flappy improved implementations below. -->
  <script>
  /* ---------------- SIMON ‚Äî vers√£o melhorada ---------------- */
  (function(){
    const pads = Array.from(document.querySelectorAll('#simon-grid .simon-pad'));
    if(!pads.length) return;
    const startBtn = document.getElementById('simon-start');
    const strictBtn = document.getElementById('simon-strict');
    const restartBtn = document.getElementById('simon-restart');
    const levelEl = document.getElementById('simon-level');
    const bestEl = document.getElementById('simon-best');

    // audio context simple tones
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = AudioContext ? new AudioContext() : null;
    const freqs = [440, 523.25, 659.25, 349.23]; // A4, C5, E5, F4-ish

    function playTone(index, duration = 450){
      if(!audioCtx) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.value = freqs[index % freqs.length];
      g.gain.value = 0;
      o.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.linearRampToValueAtTime(0.001, now);
      g.gain.exponentialRampToValueAtTime(0.15, now + 0.02);
      o.start(now);
      g.gain.exponentialRampToValueAtTime(0.001, now + duration/1000);
      o.stop(now + duration/1000 + 0.02);
    }

    // state
    let sequence = [];
    let playerIndex = 0;
    let playing = false;
    let isStrict = false;
    let busy = false;
    let level = 0;
    let best = Number(localStorage.getItem('simon-best') || 0);

    bestEl.textContent = best;

    function setLevel(n){
      level = n;
      levelEl.textContent = n;
      if(n > best){ best = n; localStorage.setItem('simon-best', best); bestEl.textContent = best; }
    }

    function randPad(){ return Math.floor(Math.random()*pads.length); }

    function flashPad(i, ms = 400){
      const pad = pads[i];
      if(!pad) return Promise.resolve();
      return new Promise(resolve=>{
        pad.classList.remove('dim');
        pad.style.filter = 'brightness(1.18)';
        playTone(i, ms);
        pad.style.transform = 'scale(1.04)';
        setTimeout(()=>{ pad.style.transform = ''; pad.style.filter=''; pad.classList.add('dim'); setTimeout(resolve, 120); }, ms);
      });
    }

    async function playSequence(){
      busy = true;
      for(let i=0;i<sequence.length;i++){
        await flashPad(sequence[i], Math.max(220, 420 - Math.min(200, level*6)));
      }
      busy = false;
    }

    async function nextRound(){
      sequence.push(randPad());
      setLevel(sequence.length);
      await playSequence();
      playerIndex = 0;
      playing = true;
    }

    function resetGame(){
      sequence = [];
      playerIndex = 0;
      playing = false;
      busy = false;
      setLevel(0);
    }

    // UI init
    pads.forEach((pad, idx)=>{
      pad.classList.add('dim');
      // touch/click
      function tryPress(){
        if(busy) return;
        if(!playing) return;
        // visual + sound
        flashPad(idx, 200);
        if(sequence[playerIndex] === idx){
          playerIndex++;
          if(playerIndex >= sequence.length){
            // correct round
            playing = false;
            setTimeout(()=> nextRound(), 450);
          }
        } else {
          // mistake
          playing = false;
          // feedback
          (async ()=>{
            busy = true;
            // flash all red-ish
            pads.forEach(p=>p.style.filter='brightness(.7) saturate(.6)');
            if(audioCtx) { try{ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.frequency.value=120; o.connect(g); g.connect(audioCtx.destination); g.gain.value=0.1; o.start(); setTimeout(()=>{ o.stop(); }, 300); } catch(e){} }
            await new Promise(r=>setTimeout(r,400));
            pads.forEach(p=>p.style.filter='');
            busy = false;
            if(isStrict){ resetGame(); setTimeout(()=>startGame(), 350); }
            else { // replay sequence
              playerIndex = 0;
              await playSequence();
              playing = true;
            }
          })();
        }
      }
      pad.addEventListener('click', tryPress);
      pad.addEventListener('touchstart', (e)=>{ e.preventDefault(); tryPress(); }, {passive:false});
    });

    async function startGame(){
      if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      resetGame();
      await new Promise(r=>setTimeout(r,150));
      nextRound();
    }

    // controls
    startBtn.addEventListener('click', ()=>{ startGame(); });
    restartBtn.addEventListener('click', ()=>{ resetGame(); startGame(); });
    strictBtn.addEventListener('click', ()=>{ isStrict = !isStrict; strictBtn.style.opacity = isStrict ? '1' : '0.6'; });

    // quick keyboard mapping 1-4
    window.addEventListener('keydown', e=>{
      if(['1','2','3','4'].includes(e.key)) {
        const idx = parseInt(e.key,10)-1;
        pads[idx] && pads[idx].click();
      }
    });

    // initial dim
    pads.forEach(p=>p.classList.add('dim'));
  })();
  </script>

  <script>
  /* ---------------- FLAPPY ‚Äî vers√£o melhorada com toque ---------------- */
  (function(){
    const canvas = document.getElementById('flappy-canvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('flappy-score');
    const bestEl = document.getElementById('flappy-best');
    const restartBtn = document.getElementById('flappy-restart');
    const pauseBtn = document.getElementById('flappy-pause');

    let best = Number(localStorage.getItem('flappy-best') || 0);
    bestEl.textContent = best;

    // responsivity
    function fit(){
      const dpr = window.devicePixelRatio || 1;
      const wrap = canvas.closest('.game-inner') || canvas.parentElement || document.body;
      const rect = wrap.getBoundingClientRect();
      const w = Math.max(120, Math.floor(rect.width));
      const h = Math.max(160, Math.floor(rect.height));
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      const rw = Math.floor(w * dpr), rh = Math.floor(h * dpr);
      if(canvas.width !== rw || canvas.height !== rh){
        canvas.width = rw; canvas.height = rh;
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
    }

    // game state
    let bird = { x: 60, y: 120, vy: 0, radius: 12 };
    let pipes = []; // {x, gapY, w}
    let gravity = 900; // px/s^2
    let flapVy = -320;
    let spawnTimer = 0;
    let spawnInterval = 1.6;
    let speed = 120;
    let last = 0;
    let score = 0;
    let running = false;
    let paused = false;

    function reset(){
      fit();
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      bird.x = Math.max(40, cssW*0.18);
      bird.y = cssH/2;
      bird.vy = 0;
      bird.radius = Math.max(8, Math.min(16, Math.floor(cssH*0.035)));
      pipes = [];
      spawnTimer = 0;
      score = 0;
      running = true;
      paused = false;
      scoreEl.textContent = score;
    }

    function spawnPipe(){
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      const gap = Math.max(80, Math.min(160, Math.floor(cssH*0.22)));
      const gapY = Math.floor(70 + Math.random() * (cssH - 140 - gap));
      pipes.push({ x: cssW + 20, gapY, w: Math.max(46, Math.floor(cssW*0.14)), passed:false });
    }

    function flap(){
      if(!running) { reset(); last = performance.now(); requestAnimationFrame(loop); return; }
      bird.vy = flapVy;
    }

    function step(dt){
      if(paused || !running) return;
      // physics
      bird.vy += gravity * dt;
      bird.y += bird.vy * dt;
      // pipes movement
      for(let p of pipes) p.x -= speed * dt;
      // spawn
      spawnTimer += dt;
      if(spawnTimer >= spawnInterval){ spawnTimer = 0; spawnPipe(); }
      // remove offscreen
      if(pipes.length && pipes[0].x + pipes[0].w < -30) pipes.shift();
      // collisions
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      if(bird.y - bird.radius <= 0 || bird.y + bird.radius >= cssH) gameOver();
      for(let p of pipes){
        if(!p.passed && p.x + p.w < bird.x){ p.passed = true; score++; scoreEl.textContent = score; if(score>best){ best = score; localStorage.setItem('flappy-best', best); bestEl.textContent = best; } }
        // check overlap
        if(bird.x + bird.radius > p.x && bird.x - bird.radius < p.x + p.w){
          if(bird.y - bird.radius < p.gapY || bird.y + bird.radius > p.gapY + Math.max(80, Math.floor(canvas.clientHeight*0.22))){
            gameOver();
          }
        }
      }
    }

    function gameOver(){
      running = false;
      // small flash
      (async ()=>{
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      })();
    }

    function draw(){
      // background
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      ctx.fillStyle = '#70c5ce';
      ctx.fillRect(0,0,cssW,cssH);
      // ground band
      ctx.fillStyle = '#6abf9f';
      ctx.fillRect(0, cssH - 40, cssW, 40);
      // pipes
      for(let p of pipes){
        const gapH = Math.max(80, Math.floor(cssH*0.22));
        ctx.fillStyle = '#2d8a57';
        ctx.fillRect(p.x, 0, p.w, p.gapY);
        ctx.fillRect(p.x, p.gapY + gapH, p.w, cssH - (p.gapY + gapH) - 40);
        // pipe cap
        ctx.fillStyle = '#1f5f3f';
        ctx.fillRect(p.x, p.gapY - 6, p.w, 6);
        ctx.fillRect(p.x, p.gapY + gapH, p.w, 6);
      }
      // bird
      ctx.beginPath();
      ctx.fillStyle = '#ffde59';
      ctx.arc(bird.x, bird.y, bird.radius, 0, Math.PI*2);
      ctx.fill();
      // score (drawn outside canvas area earlier) - keep simple
    }

    function loop(ts){
      if(!last) last = ts;
      const dt = Math.min(0.05, (ts - last)/1000);
      last = ts;
      step(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // input
    canvas.addEventListener('click', (e)=>{ flap(); });
    canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); flap(); }, {passive:false});
    window.addEventListener('keydown', (e)=>{ if(e.key===' ' || e.key==='ArrowUp') { e.preventDefault(); flap(); } if(e.key==='p' || e.key==='P'){ paused = !paused; pauseBtn.textContent = paused ? 'Retomar' : 'Pausar'; } });

    restartBtn && restartBtn.addEventListener('click', ()=>{ reset(); last = performance.now(); requestAnimationFrame(loop); });
    pauseBtn && pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'Retomar' : 'Pausar'; });

    // init
    window.addEventListener('resize', ()=>{ fit(); });
    window.addEventListener('load', ()=>{ fit(); reset(); last = performance.now(); requestAnimationFrame(loop); });
    setTimeout(()=>{ if(!canvas.width) fit(); }, 200);
  })();
  </script>

  <!-- Note: Tetris / Memory / Pong scripts are expected to be in your index.html already.
       If you replaced the whole file earlier with one that already contains them, they continue to work.
       If you need me to merge exact Tetris/Memory/Pong code into this file, tell me and I will produce the complete combined file. -->
</body>
</html>
