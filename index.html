<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Meus Jogos ‚Äî Tetris, Memory, Pong</title>
  <style>
    :root{
      --card-bg:#fff;
      --accent:#3f7bff;
      --page-pad:28px;
      --card-w:360px;
      --page-max:1200px;
    }
    body{
      margin:0;
      font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background:linear-gradient(120deg,#e9f0ff,#f8fafc);
      color:#17202a;
      padding:var(--page-pad);
    }
    h1{text-align:center;margin:0 0 18px}

    /* Layout */
    .games-row{
      display:flex;
      gap:20px;
      justify-content:center;
      align-items:stretch;
      flex-wrap:wrap;
      max-width:var(--page-max);
      margin:0 auto;
    }
    .game-card{
      flex:0 0 var(--card-w);
      width:var(--card-w);
      min-height:480px;
      display:flex;
      flex-direction:column;
      background:var(--card-bg);
      border-radius:12px;
      box-shadow:0 12px 36px rgba(16,24,40,0.06);
      overflow:hidden;
    }
    .game-card>h2{ margin:12px 8px; font-size:1.05rem; text-align:center; flex:0 0 auto; }
    .game-card__body{
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:12px;
      box-sizing:border-box;
    }

    .game-inner{
      flex:1 1 auto;
      width:100%;
      max-height:360px;
      min-height:180px;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:6px;
      box-sizing:border-box;
    }
    .game-inner canvas,
    .game-inner img,
    .game-inner .board{
      max-width:100%;
      max-height:100%;
      width:auto !important;
      height:auto !important;
      display:block;
      object-fit:contain;
    }

    .controls{ display:flex; gap:8px; justify-content:center; margin-top:12px; }
    .btn{ background:var(--accent); color:#fff; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
    .btn:disabled{ opacity:.6; cursor:default; }

    /* Memory cells */
    .cell{
      border-radius:8px;
      background:#56606a;
      color:transparent;
      border:0;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:transform .18s, background .18s, color .18s;
      box-shadow: 0 6px 14px rgba(10,20,40,0.05);
    }
    .cell.open{ background:#fff; color:#111; transform:scale(1.04) }
    .cell.matched{ background:#dff7e7; color:#0b5132; cursor:default }

    /* Memory board: ensure grid layout and centering */
    #mem-board {
      display: grid;
      gap: 8px;
      justify-items: center;
      align-items: center;
      width: 100%;
      justify-content: center;
    }

    @media (max-width:880px){
      .games-row{ gap:14px }
      .game-card{ flex:1 1 92%; width:auto; min-height:auto }
      .game-inner{ max-height:420px }
    }
  </style>
</head>
<body>
  <h1>Meus Jogos</h1>

  <div class="games-row">

    <!-- TETRIS -->
    <div class="game-card" id="tetris-card">
      <h2>Tetris (responsivo)</h2>
      <div class="game-card__body">
        <div style="display:flex;gap:12px;justify-content:center;font-weight:700">
          <div>Pontos: <span id="tetris-score">0</span></div>
          <div>N√≠vel: <span id="tetris-level">1</span></div>
        </div>

        <div class="game-inner">
          <canvas id="tetris-canvas" data-cols="10" data-rows="20"
                  style="width:100%; height:100%; display:block; border-radius:10px; background:#111;"></canvas>
        </div>

        <div class="controls" style="margin-top:auto">
          <button id="tetris-restart" class="btn">Reiniciar</button>
          <button id="tetris-pause" class="btn">Pausar</button>
        </div>
      </div>
    </div>

    <!-- MEMORY -->
    <div class="game-card" id="mem-card">
      <h2>Memory ‚Äî N√≠veis Din√¢micos</h2>
      <div class="game-card__body">
        <div style="display:flex;gap:12px;justify-content:center;font-weight:700">
          <div>N√≠vel: <span id="mem-lvl">1</span></div>
          <div>Movimentos: <span id="mem-moves">0</span></div>
          <div>Pontua√ß√£o: <span id="mem-score">0</span></div>
        </div>

        <div class="game-inner">
          <div id="mem-board" aria-live="polite" style="margin-top:10px"></div>
        </div>

        <div class="controls" style="margin-top:auto">
          <button id="mem-restart" class="btn">Reiniciar</button>
          <button id="mem-next" class="btn" disabled>Pr√≥ximo N√≠vel</button>
        </div>
      </div>
    </div>

    <!-- PONG -->
    <div class="game-card" id="pong-card">
      <h2>Pong</h2>
      <div class="game-card__body">
        <div style="display:flex;gap:12px;justify-content:center;font-weight:700">
          <div>Jogador A: <span id="pong-score-a">0</span></div>
          <div>Jogador B: <span id="pong-score-b">0</span></div>
        </div>

        <div class="game-inner" style="margin-top:10px;">
          <canvas id="pong-canvas" style="width:100%; height:100%; display:block; border-radius:10px; background:#0b0b0b;"></canvas>
        </div>

        <div class="controls" style="margin-top:auto">
          <button id="pong-restart" class="btn">Reiniciar</button>
          <button id="pong-pause" class="btn">Pausar</button>
        </div>
      </div>
    </div>

  </div>

  <!-- ================= TETRIS: implementation ================= -->
  <script>
  (function(){
    const canvas = document.getElementById('tetris-canvas');
    const scoreEl = document.getElementById('tetris-score');
    const levelEl = document.getElementById('tetris-level');
    const btnRestart = document.getElementById('tetris-restart');
    const btnPause = document.getElementById('tetris-pause');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');

    const COLS = parseInt(canvas.dataset.cols,10) || 10;
    const ROWS = parseInt(canvas.dataset.rows,10) || 20;

    const SHAPES = {
      I: [[1,1,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]],
      O: [[1,1],[1,1]],
      S: [[0,1,1],[1,1,0]],
      T: [[0,1,0],[1,1,1]],
      Z: [[1,1,0],[0,1,1]]
    };
    const COLORS = { I:'#00d2ff', J:'#ff6b6b', L:'#ffd166', O:'#ffd86b', S:'#2ecc71', T:'#9b5cff', Z:'#ff6bc6' };

    function rotate(matrix){
      const m = matrix.length, n = matrix[0].length;
      const out = Array.from({length:n},()=>Array(m).fill(0));
      for(let r=0;r<m;r++) for(let c=0;c<n;c++) out[c][m-1-r]=matrix[r][c];
      return out;
    }
    function generateRotations(shape){
      const rotations = [];
      let current = shape.map(row=>row.slice());
      for(let i=0;i<4;i++){
        if(!rotations.some(r => JSON.stringify(r)===JSON.stringify(current))) rotations.push(current);
        current = rotate(current);
      }
      return rotations;
    }

    const PIECES = Object.keys(SHAPES).reduce((acc,k)=>{
      acc[k]=generateRotations(SHAPES[k]);
      return acc;
    },{});

    let board = [];
    let curr = null;
    let nextQueue = [];
    let score = 0;
    let level = 1;
    let linesCleared = 0;
    let dropAccumulator = 0;
    let lastTime = 0;
    let gameOver = false;
    let paused = false;

    function fitCanvasToContainer(){
      const dpr = window.devicePixelRatio || 1;
      const wrapper = canvas.closest('.game-inner') || canvas.parentElement || document.body;
      const rect = wrapper.getBoundingClientRect();
      const displayW = Math.max(40, Math.floor(rect.width));
      const displayH = Math.max(40, Math.floor(rect.height));
      canvas.style.width = displayW + 'px';
      canvas.style.height = displayH + 'px';
      const resW = Math.floor(displayW * dpr);
      const resH = Math.floor(displayH * dpr);
      if (canvas.width !== resW || canvas.height !== resH) {
        canvas.width = resW; canvas.height = resH;
        ctx.setTransform(dpr,0,0,dpr,0,0);
        return true;
      }
      return false;
    }
    function computeCellSize(){
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      const cellW = Math.floor(cssW / COLS), cellH = Math.floor(cssH / ROWS);
      return Math.max(6, Math.min(cellW, cellH));
    }
    function computeOffsets(cell){
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      const gridW = cell * COLS, gridH = cell * ROWS;
      return { offsetX: Math.floor((cssW - gridW)/2), offsetY: Math.floor((cssH - gridH)/2) };
    }

    function createBoard(){
      board = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
    }
    function spawnPiece(){
      if(nextQueue.length < 3) fillBag();
      const type = nextQueue.shift();
      const rotations = PIECES[type];
      const rotIndex = 0;
      const matrix = rotations[rotIndex];
      const x = Math.floor((COLS - matrix[0].length)/2);
      const y = -matrix.length;
      curr = {type, rotIndex, x, y};
      if(collision(curr,0,0,rotIndex)) gameOver = true;
    }
    function fillBag(){
      const bag = Object.keys(PIECES).slice();
      for(let i=bag.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]];
      }
      nextQueue.push(...bag);
    }
    function collision(piece,dx,dy,rotIdx){
      const rotations = PIECES[piece.type];
      const mat = rotations[rotIdx];
      for(let r=0;r<mat.length;r++){
        for(let c=0;c<mat[r].length;c++){
          if(!mat[r][c]) continue;
          const nx = piece.x + c + dx;
          const ny = piece.y + r + dy;
          if(nx < 0 || nx >= COLS) return true;
          if(ny >= ROWS) return true;
          if(ny >= 0 && board[ny][nx]) return true;
        }
      }
      return false;
    }
    function lockPiece(){
      const rotations = PIECES[curr.type];
      const mat = rotations[curr.rotIndex];
      for(let r=0;r<mat.length;r++){
        for(let c=0;c<mat[r].length;c++){
          if(!mat[r][c]) continue;
          const nx = curr.x + c;
          const ny = curr.y + r;
          if(ny >= 0 && ny < ROWS && nx >=0 && nx < COLS) board[ny][nx] = curr.type;
        }
      }
      clearLines();
      spawnPiece();
    }
    function clearLines(){
      let removed = 0;
      for(let r=ROWS-1;r>=0;r--){
        if(board[r].every(cell => cell !== 0)){
          board.splice(r,1);
          board.unshift(Array(COLS).fill(0));
          removed++;
          r++;
        }
      }
      if(removed>0){
        linesCleared += removed;
        score += [0,40,100,300,1200][removed] * level;
        const newLevel = Math.floor(linesCleared / 10) + 1;
        if(newLevel !== level) level = newLevel;
        scoreEl.textContent = score;
        levelEl.textContent = level;
      }
    }

    function move(dx){
      if(!curr || gameOver || paused) return;
      if(!collision(curr,dx,0,curr.rotIndex)) curr.x += dx;
    }
    function rotateCurr(){
      if(!curr || gameOver || paused) return;
      const rotations = PIECES[curr.type];
      const nextRot = (curr.rotIndex + 1) % rotations.length;
      const kicks = [0,-1,1,-2,2];
      for(let k of kicks){
        if(!collision(curr,k,0,nextRot)){
          curr.x += k;
          curr.rotIndex = nextRot;
          return;
        }
      }
    }
    function softDrop(){
      if(!curr || gameOver || paused) return false;
      if(!collision(curr,0,1,curr.rotIndex)){
        curr.y += 1;
        return true;
      } else {
        if(curr.y < 0) gameOver = true;
        else lockPiece();
        return false;
      }
    }
    function hardDrop(){
      if(!curr || gameOver || paused) return;
      while(!collision(curr,0,1,curr.rotIndex)){ curr.y++; score += 2; }
      lockPiece();
      scoreEl.textContent = score;
    }

    window.addEventListener('keydown', (e)=>{
      if(e.key === 'ArrowLeft'){ e.preventDefault(); move(-1); }
      else if(e.key === 'ArrowRight'){ e.preventDefault(); move(1); }
      else if(e.key === 'ArrowUp'){ e.preventDefault(); rotateCurr(); }
      else if(e.key === 'ArrowDown'){ e.preventDefault(); softDrop(); score += 1; scoreEl.textContent = score; }
      else if(e.key === ' '){ e.preventDefault(); hardDrop(); }
      else if(e.key === 'p' || e.key === 'P'){ togglePause(); }
    });

    btnRestart && btnRestart.addEventListener('click', ()=>{ init(true); });
    btnPause && btnPause.addEventListener('click', ()=>{ togglePause(); });

    function togglePause(){
      paused = !paused;
      btnPause.textContent = paused ? 'Retomar' : 'Pausar';
    }

    function draw(){
      fitCanvasToContainer();
      const cell = computeCellSize();
      const {offsetX, offsetY} = computeOffsets(cell);
      ctx.fillStyle = '#0b0b0b';
      ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);

      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const x = offsetX + c * cell;
          const y = offsetY + r * cell;
          ctx.fillStyle = '#101115';
          ctx.fillRect(x, y, cell, cell);
          if(board[r][c]){
            const col = COLORS[board[r][c]] || '#999';
            ctx.fillStyle = col;
            ctx.fillRect(x+1, y+1, cell-2, cell-2);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.strokeRect(x+1, y+1, cell-2, cell-2);
          } else {
            ctx.fillStyle = 'rgba(255,255,255,0.02)';
            ctx.fillRect(x+1, y+1, cell-2, cell-2);
          }
        }
      }

      if(curr){
        const rotations = PIECES[curr.type];
        const mat = rotations[curr.rotIndex];
        const color = COLORS[curr.type] || '#fff';
        for(let r=0;r<mat.length;r++){
          for(let c=0;c<mat[r].length;c++){
            if(!mat[r][c]) continue;
            const x = offsetX + (curr.x + c) * cell;
            const y = offsetY + (curr.y + r) * cell;
            if(y + cell < offsetY) continue;
            ctx.fillStyle = color;
            ctx.fillRect(x+1, y+1, cell-2, cell-2);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.strokeRect(x+1, y+1, cell-2, cell-2);
          }
        }
      }

      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.strokeRect(offsetX+0.5, offsetY+0.5, cell*COLS-1, cell*ROWS-1);
    }

    function dropIntervalForLevel(l){ return Math.max(150, 800 - (l-1)*70); }

    function loop(time){
      if(!lastTime) lastTime = time;
      const dt = time - lastTime;
      lastTime = time;
      if(!paused && !gameOver){
        dropAccumulator += dt;
        const interval = dropIntervalForLevel(level);
        while(dropAccumulator >= interval){
          softDrop();
          dropAccumulator -= interval;
        }
      }
      draw();
      requestAnimationFrame(loop);
    }

    function init(forceReset){
      createBoard();
      nextQueue = [];
      fillBag();
      spawnPiece();
      score = 0; level = 1; linesCleared = 0;
      gameOver = false; paused = false; dropAccumulator = 0; lastTime = 0;
      scoreEl.textContent = score;
      levelEl.textContent = level;
    }

    fitCanvasToContainer();
    init(true);
    requestAnimationFrame(loop);

    window.tetrisCanvasHelper = { fitCanvasToContainer, computeCellSize, computeOffsets, canvas, ctx, COLS, ROWS };

    let resizeTimer;
    window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer = setTimeout(()=>{ fitCanvasToContainer(); }, 100); });
  })();
  </script>

  <!-- ================= MEMORY (grid & centered) ================= -->
  <script>
  (function(){
    const SYMBOLS = ['üçé','üçã','üçá','üçì','üçâ','üçí','üçä','ü•ù','üçç','ü•ë','üçë','üçå','üçê','üçà','ü••','üçè','üåΩ','ü•ï','ü•î','üå∂Ô∏è'];
    const BASE = [{r:2,c:2},{r:2,c:3},{r:3,c:4},{r:4,c:4},{r:4,c:5}];
    const MAX_SIZE = 8;
    function getLevelSpec(i){
      if(i < BASE.length) return normalize(BASE[i]);
      const extra = i - BASE.length;
      const incRows = Math.floor(extra/2);
      const incCols = extra % 2;
      let r = 4 + incRows, c = 5 + incCols + Math.floor(extra/4);
      r = Math.min(r, MAX_SIZE); c = Math.min(c, MAX_SIZE);
      return normalize({r,c});
    }
    function normalize(spec){
      let {r,c} = spec;
      if((r*c)%2!==0){ if(c<MAX_SIZE) c++; else if(r<MAX_SIZE) r++; else c++; }
      return {r,c};
    }

    let level = 0, rows=4, cols=4, board=[], first=null, second=null, lock=false, moves=0, score=0, matches=0;
    const boardEl = document.getElementById('mem-board');
    const movesEl = document.getElementById('mem-moves');
    const scoreEl = document.getElementById('mem-score');
    const lvlEl = document.getElementById('mem-lvl');
    const restartBtn = document.getElementById('mem-restart');
    const nextBtn = document.getElementById('mem-next');

    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
    function getCellSize(){ if(window.innerWidth < 420) return 48; if(window.innerWidth < 520) return 56; return 64; }

    function build(){
      const spec = getLevelSpec(level);
      rows = spec.r; cols = spec.c;
      const pairs = (rows*cols)/2;
      const pool = SYMBOLS.slice(0);
      shuffle(pool);
      const chosen = pool.slice(0,pairs);
      const symbols = shuffle([...chosen, ...chosen]);
      board = symbols.map((s,i)=>({id:i,symbol:s,matched:false}));

      const cellSize = getCellSize();
      boardEl.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
      boardEl.style.width = '100%';
      boardEl.style.justifyContent = 'center';
      boardEl.style.margin = '0 auto';
      boardEl.style.gap = '8px';

      boardEl.innerHTML = '';
      board.forEach(card=>{
        const btn = document.createElement('button');
        btn.className = 'cell';
        btn.dataset.id = card.id;
        btn.style.width = cellSize + 'px';
        btn.style.height = cellSize + 'px';
        btn.style.fontSize = Math.max(16, Math.round(cellSize * 0.45)) + 'px';
        btn.innerHTML = '<span aria-hidden="true"></span>';
        btn.addEventListener('click', onClick);
        boardEl.appendChild(btn);
      });

      first = second = null; lock = false; moves = 0; score = 0; matches = 0;
      movesEl && (movesEl.textContent = moves); scoreEl && (scoreEl.textContent = score); lvlEl && (lvlEl.textContent = level + 1);
      nextBtn && (nextBtn.disabled = true);
    }

    function openCard(el,card){ el.classList.add('open'); el.querySelector('span').textContent = card.symbol; }
    function closeCard(el){ el.classList.remove('open'); el.querySelector('span').textContent = ''; }
    function onClick(e){
      if(lock) return;
      const el = e.currentTarget;
      const id = +el.dataset.id;
      const card = board[id];
      if(card.matched) return;
      if(first && first.id === id) return;
      openCard(el,card);
      if(!first){ first = {id,el,card}; return; }
      second = {id,el,card};
      moves++; movesEl && (movesEl.textContent = moves); lock = true;
      if(first.card.symbol === second.card.symbol){
        setTimeout(()=>{
          first.card.matched = second.card.matched = true;
          first.el.classList.add('matched');
          second.el.classList.add('matched');
          matches++; score += 10; scoreEl && (scoreEl.textContent = score);
          first = second = null; lock = false; checkWin();
        }, 350);
      } else {
        setTimeout(()=>{
          closeCard(first.el); closeCard(second.el);
          score = Math.max(0, score - 1); scoreEl && (scoreEl.textContent = score);
          first = second = null; lock = false;
        }, 700);
      }
    }
    function checkWin(){
      const totalPairs = (rows*cols)/2;
      if(matches === totalPairs){
        nextBtn && (nextBtn.disabled = (level >= 999));
        if(nextBtn && !nextBtn.disabled) nextBtn.focus();
      }
    }
    restartBtn && restartBtn.addEventListener('click', build);
    nextBtn && nextBtn.addEventListener('click', ()=>{ level++; build(); });
    let resizeTimer;
    window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer = setTimeout(build, 180); });
    build();
  })();
  </script>

  <!-- ================= PONG (added) ================= -->
  <script>
  (function(){
    const canvas = document.getElementById('pong-canvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const scoreAEl = document.getElementById('pong-score-a');
    const scoreBEl = document.getElementById('pong-score-b');
    const btnRestart = document.getElementById('pong-restart');
    const btnPause = document.getElementById('pong-pause');

    function fitCanvas(){
      const dpr = window.devicePixelRatio || 1;
      const wrap = canvas.closest('.game-inner') || canvas.parentElement || document.body;
      const rect = wrap.getBoundingClientRect();
      const w = Math.max(50, Math.floor(rect.width));
      const h = Math.max(50, Math.floor(rect.height));
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      const rw = Math.floor(w * dpr), rh = Math.floor(h * dpr);
      if(canvas.width !== rw || canvas.height !== rh){
        canvas.width = rw; canvas.height = rh;
        ctx.setTransform(dpr,0,0,dpr,0,0);
        return true;
      }
      return false;
    }

    let paddleW = 8, paddleH = 80;
    let ballSize = 10;
    let speed = 280;
    let left = { x:0, y:0, vy:0, score:0 };
    let right = { x:0, y:0, vy:0, score:0 };
    let ball = { x:0, y:0, vx:0, vy:0 };
    let lastTime = 0;
    let paused = false;

    function resizeMetrics(){
      fitCanvas();
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;
      paddleH = Math.max(40, Math.floor(cssH * 0.18));
      paddleW = Math.max(6, Math.floor(cssW * 0.02));
      ballSize = Math.max(6, Math.floor(Math.min(cssW, cssH) * 0.03));
      left.x = 12;
      right.x = cssW - 12 - paddleW;
      left.y = Math.floor((cssH - paddleH)/2);
      right.y = Math.floor((cssH - paddleH)/2);
      spawnBall();
    }

    function spawnBall(direction){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ball.x = Math.floor(w / 2);
      ball.y = Math.floor(h / 2);
      const angle = (Math.random() * 0.6 - 0.3);
      const dir = (direction === 'left') ? -1 : (direction === 'right') ? 1 : (Math.random()<0.5? -1:1);
      const mag = speed + Math.random()*60;
      ball.vx = dir * mag * Math.cos(angle);
      ball.vy = mag * Math.sin(angle);
    }

    function resetScores(){
      left.score = 0; right.score = 0;
      updateScoreUI();
    }
    function updateScoreUI(){
      scoreAEl.textContent = left.score;
      scoreBEl.textContent = right.score;
    }

    function step(dt){
      if(paused) return;
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      left.y += left.vy * dt;
      right.y += right.vy * dt;
      left.y = Math.max(0, Math.min(cssH - paddleH, left.y));
      right.y = Math.max(0, Math.min(cssH - paddleH, right.y));
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;
      if(ball.y - ballSize/2 <= 0){ ball.y = ballSize/2; ball.vy = -ball.vy; }
      if(ball.y + ballSize/2 >= cssH){ ball.y = cssH - ballSize/2; ball.vy = -ball.vy; }
      if(ball.x - ballSize/2 <= left.x + paddleW){
        if(ball.y >= left.y && ball.y <= left.y + paddleH){
          ball.x = left.x + paddleW + ballSize/2;
          const rel = (ball.y - (left.y + paddleH/2)) / (paddleH/2);
          const speedMul = 1.06;
          const angle = rel * 0.9;
          const mag = Math.hypot(ball.vx, ball.vy) * speedMul;
          ball.vx = Math.abs(mag * Math.cos(angle));
          ball.vy = mag * Math.sin(angle);
        }
      }
      if(ball.x + ballSize/2 >= right.x){
        if(ball.y >= right.y && ball.y <= right.y + paddleH){
          ball.x = right.x - ballSize/2;
          const rel = (ball.y - (right.y + paddleH/2)) / (paddleH/2);
          const speedMul = 1.06;
          const angle = rel * 0.9;
          const mag = Math.hypot(ball.vx, ball.vy) * speedMul;
          ball.vx = -Math.abs(mag * Math.cos(angle));
          ball.vy = mag * Math.sin(angle);
        }
      }
      if(ball.x < -50){
        right.score++; updateScoreUI(); spawnBall('right');
      } else if(ball.x > cssW + 50){
        left.score++; updateScoreUI(); spawnBall('left');
      }
    }

    function draw(){
      ctx.fillStyle = '#0b0b0b';
      ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      const dashH = 12;
      for(let y = 0; y < canvas.clientHeight; y += dashH*2){
        ctx.fillRect(Math.floor(canvas.clientWidth/2)-1, y + 6, 2, dashH);
      }
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(left.x, left.y, paddleW, paddleH);
      ctx.fillRect(right.x, right.y, paddleW, paddleH);
      ctx.beginPath();
      ctx.fillStyle = '#ff7b7b';
      ctx.arc(ball.x, ball.y, ballSize/2, 0, Math.PI*2);
      ctx.fill();
    }

    function loop(ts){
      if(!lastTime) lastTime = ts;
      const dt = (ts - lastTime)/1000;
      lastTime = ts;
      step(dt);
      draw();
      requestAnimationFrame(loop);
    }

    window.addEventListener('keydown', e => {
      if(e.key === 'w' || e.key === 'W') left.vy = -speed;
      if(e.key === 's' || e.key === 'S') left.vy = speed;
      if(e.key === 'ArrowUp') right.vy = -speed;
      if(e.key === 'ArrowDown') right.vy = speed;
      if(e.key === 'p' || e.key === 'P') { paused = !paused; btnPause.textContent = paused ? 'Retomar' : 'Pausar'; }
    });
    window.addEventListener('keyup', e => {
      if(e.key === 'w' || e.key === 'W') left.vy = 0;
      if(e.key === 's' || e.key === 'S') left.vy = 0;
      if(e.key === 'ArrowUp') right.vy = 0;
      if(e.key === 'ArrowDown') right.vy = 0;
    });

    btnRestart && btnRestart.addEventListener('click', ()=>{
      resetScores(); spawnBall(); paused = false; btnPause && (btnPause.textContent = 'Pausar');
    });
    btnPause && btnPause.addEventListener('click', ()=>{ paused = !paused; btnPause.textContent = paused ? 'Retomar' : 'Pausar'; });

    function init(){
      resetScores();
      resizeMetrics();
      spawnBall();
      lastTime = 0;
      requestAnimationFrame(loop);
    }

    let resizeTimer;
    window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer = setTimeout(()=>{ resizeMetrics(); }, 120); });

    window.addEventListener('load', ()=>{ resizeMetrics(); setTimeout(()=>{ init(); }, 80); });
    setTimeout(()=>{ if(!canvas.width) resizeMetrics(); }, 200);
  })();
  </script>

</body>
</html>
